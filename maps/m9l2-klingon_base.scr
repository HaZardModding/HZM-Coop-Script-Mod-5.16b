//-----------------------------------------------------------------
//
//  EF2 Level Script File
//
//  Level:        m9l2-klingon_base	  
//  Script By:    Benson R., Brian E., Adam B., Jerry K.
//  Geometry By:  Richard H., Jerry K., Benson R., Adam B.
//  Created on:   1/24/2003
//
//  Last Edited By: Benson R
//
//-----------------------------------------------------------------


//===================================================================================================================================================
//===================================================================================================================================================
//  DEFINE SCRIPT
//===================================================================================================================================================
//===================================================================================================================================================

void main();

//--- setup routines
void setupArena();
void setupBoss();
void setupVariables();

//--- arena functions
void arenaVent_Damage();
void arenaVent_Fire();
void arenaSwitchMoveBoss_Execute();
void arenaSwitchMoveBoss_Display_BossInControl();
void arenaSwitchMoveBoss_Display_CanPosition();
void arenaSwitchMoveBoss_Display_MoveToVent();
void arenaSwitchFireVent_Execute();
void arenaSwitchFireVent_Display_Ready();
void arenaSwitchFireVent_Display_Firing();
void arenaSwitchFireVent_Display_Charging();
void arenaScan_Damage();
void arenaScan_ShowBeam();
void arenaScan_DoScan();
void arenaScan_HideBeam();
float arenaAirlock_PickAirlock();
entity arenaAirlock_GetADoor( float intAirlock );
entity arenaAirlock_GetBDoor( float intAirlock );
void arenaAirlock_OpenAirlock( float intAirlock );
void arenaFlameburst_Activate();
void arenaFlameburst_DoDamage();
void arenaFlameburst_OpenDoors();
void arenaFlameburst_Fire();
void arenaFlameburst_CloseDoors();
void arenaBossDock_CinematicRetract();
void arenaBossDock_ExtendPhase1();
void arenaBossDock_ExtendPhase2();
void arenaBossDock_RetractPhase1();
void arenaBossDock_RetractPhase2();

//--- boss think functions
void bossThink_StateEvalLoop();
void bossThink_AttackEvalLoop();
float bossThink_AttackEval_Boost();
void bossThink_AttackEval_BoostReset();
float bossThink_AttackEval_Scan();
void bossThink_AttackEval_ScanReset();
float bossThink_AttackEval_Flameburst();
void bossThink_AttackEval_FlameburstReset();
float bossThink_AttackEval_Airlock();
void bossThink_AttackEval_AirlockReset();
void bossThink_MercDeath();

//--- boss action functions
float bossAction_MoveRequest( vector vecGoal, float intAngularTolerance );
void bossAction_MoveStop();
void bossAction_Taunt( float fltAttack );
float bossAction_TauntChoose( float fltPrevious );
void bossAction_TauntSay( string strDialog );
void bossAction_PhaseChangeState_Start();
void bossAction_PhaseChangeState_Cinematic();
void bossAction_PhaseChangeState_Post();
void bossAction_BrokenState_Start();
void bossAction_BrokenState_MoveToVent();
void bossAction_BrokenState_Wait();
void bossAction_BrokenState_AtVent();
void bossAction_BrokenState_Post();
void bossAction_ScanState_Start();
void bossAction_ScanState_MoveToSafety();
void bossAction_ScanState_AtSafety();
void bossAction_ScanState_Post();
void bossAction_BoostState_Start();
void bossAction_BoostState_MoveToGoal();
void bossAction_BoostState_AtGoal();
void bossAction_BoostState_Post();

//--- boss get functions
void bossGet_WhileUpdating();
float bossGet_VentDamageAllowed();
float bossGet_PlayerCanPosition();
float bossGet_CanAttack();
float bossGet_MoveToVent();
float bossGet_AtVent();
float bossGet_State();
float bossGet_StatePhaseChange();
float bossGet_StateBroken();
float bossGet_StateScan();
float bossGet_StateBoost();

//--- boss set functions
void bossSet_Updating();
void bossSet_UpdatingDone();
void bossSet_VentDamageAllowed(float boolStateToSet );
void bossSet_PlayerCanPosition( float boolStateToSet );
void bossSet_CanAttack( float boolStateToSet );
void bossSet_MoveToVent( float boolStateToSet );
void bossSet_AtVent( float boolStateToSet );
void bossSet_State( float fltStateToSet );
void bossSet_StatePhaseChange( float fltStateToSet );
void bossSet_StateBroken( float fltStateToSet );
void bossSet_StateScan( float fltStateToSet );
void bossSet_StateBoost( float fltStateToSet );

//--- AI initiated functions
void bossAI_EnterRepairState();
void bossAI_ExitRepairState();
void bossAI_EnterPhase2();
void bossAI_EnterPhase3();
void bossAI_EnterPhase4();

//--- common functions
float commonGet_AngularDistance( vector vecTarget, vector vecStart );
float commonGet_WithinAngularTolerance( float intAngularDistance, float intAngularTolerance );


//-----------------------------------------------------------
//-----------------------------------------------------------
//--- constants
//--- preset parameters that can be adjusted later

//--- boss move parameter constants
float BOSS_MOVE_SPEED_NORMAL = 8;			//normal movement speed in degrees /second
float BOSS_MOVE_SPEED_SCAN = 50;			//moving to scan safety spot speed in degrees /second
float BOSS_MOVE_SPEED_BOOST = 60;			//boost movement speed in degrees /second
float BOSS_MOVE_SPEED_TO_VENT = 30;			//player moves rig to vent spot in degrees /second
float BOSS_MOVE_THRESHOLD = 45;				//the distance the player needs to be away from
											//the boss before the boss will attempt to move
											//towards him again.  This is in degrees
float BOSS_MOVE_TOLERANCE_NORMAL = 5;		//this is the tolerance for determining how close
											//is considered close enough for reaching it's
											//goal point while normal moving.  This is in degrees.

float BOSS_MOVE_TOLERANCE_BOOST = 8;		//this is the tolerance for determining how close
											//is considered close enough for reaching it's
											//goal point while boost moving.  This is in degrees.

float BOSS_MOVE_TOLERANCE_SCAN = 4;			//this is the tolerance for determining how close
											//is considered close enough for reaching it's
											//goal point while getting into the dock for a scan.  This is in degrees.
											
//--- evaluation cycle times
float BOSS_EVAL_ATTACK_CYCLE_TIME = .25;	//the wait time in seconds between attack evaluation cycles
float BOSS_EVAL_STATE_CYCLE_TIME = .1;		//the wait time in seconds between master evalutaion cycles

//--- attack counter limits and reset times
float BOSS_BOOST_COUNTER_LIMIT = 10;		//the counter to check how long the player is staying in
											//a position that will make the boss perform a boost attack
float BOSS_BOOST_RESET_TIME = 20;			//time in seconds of how long after a boost attack is
											//finished before the boss can boost attack again

float BOSS_FLAMEBURST_COUNTER_LIMIT = 20;	//the counter to check how long the player is staying in
											//a position that will make the boss perform a flameburst attack
float BOSS_FLAMEBURST_RESET_TIME = 45;		//time in seconds of how long after a flameburst attack
											//is finished before the boss can flameburst attack again

float BOSS_AIRLOCK_COUNTER_LIMIT = 10;		//the counter to check how long the player is staying in
											//a position that will make the boss perform a airlock attack											
float BOSS_AIRLOCK_RESET_TIME = 40;			//time in seconds of how long after an airlock
											//attack has been finished before the boss can
											//airlock attack again

float BOSS_SCAN_COUNTER_LIMIT = 10;			//the counter to check how long the player is staying in
											//a position that will make the boss perform a Scan attack																					
float BOSS_SCAN_RESET_TIME = 45;			//time in seconds of how long after a Scan
											//attack has been finished before the boss can
											//Scan attack again

//--- phase change constants
float PHASE_CHANGE_ANIMATION_DELAY = 1.3;	//the amount of time to wait before turning the rig's AI off
											//accounts for the animation being played

float PHASE_CHANGE_BOSS_ACTIVATION_DISTANCE = 128;		//the distance the player has to be from lurok in stage 4
														//for the boss to activate and become solid

//--- boost parameter constants
float BOOST_BLINDSPOT_TOLERANCE = 45;		//this is how many degrees +/- from the blindspot the player
											//has to be to be considered within the blindspot.  The blindspot
											//is 180 degrees around from whereever the rig is at that moment

//--- vent parameter constants
float VENT_ACTIVE_TIME = 2.5;				//time in seconds the vent stays active
float VENT_CHARGE_TIME = 8;					//time in seconds that the vent needs to charge
											//before it can be activated again
float VENT_DAMAGE = 500;					//the amount of damage to do to the rig
string VENT_DAMAGE_TYPE = "crush";			//the damage type to do to the rig

float VENT_DISTANCE_TOLERANCE = 10;			//the number of degrees near the bossVentSpot the boss has to be
											//to be considered close enough to get damaged when the vent's active

//--- Scan parameter constants
float SCAN_BEAM_DAMAGE = 50;				//the amount of damage to do per touch of the beam
											//it checks for a touch every .05 seconds as the beam's moving
string SCAN_BEAM_DAMAGE_TYPE = "electric";	//the type of damage to do
float SCAN_BEAM_DAMAGE_TOLERANCE = 6;		//the number of degrees near the beam the player has to be
											//to get damaged by it.  This is to account for the low
											//granularity of position checks on the beam
float SCAN_BEAM_TIME_PHASE2 = 10;			//the time it takes for the Scan beam to sweep all the
											//way around the arena for Phase 2

float SCAN_BEAM_TIME_PHASE3 = 8;			//the time it takes for the Scan beam to sweep all the
											//way around the arena for Phase 3

//--- airlock door parameter constants
float AIRLOCK_DOOR_TIME = 8;				//the amount of time it takes an airlock door to open

//--- flameburst parameter constants
float FLAMEBURST_DOOR_TIME_PHASE1 = 5;			//time it takes for the flameburst doors to open on phase1
float FLAMEBURST_DOOR_TIME_PHASE2 = 4;			//time it takes for the flameburst doors to open on phase2
float FLAMEBURST_DOOR_TIME_PHASE3 = 3;			//time it takes for the flameburst doors to open on phase3
float FLAMEBURST_DOOR_FIRE_DELAY_PHASE1 = 2;	//delay time from doors opening to firing on phase1
float FLAMEBURST_DOOR_FIRE_DELAY_PHASE2 = 1;	//delay time from doors opening to firing on phase2
float FLAMEBURST_DOOR_FIRE_DELAY_PHASE3 = .5;	//delay time from doors opening to firing on phase3
float FLAMEBURST_FIRE_DURATION = 5;				//how long the burst goes for
float FLAMEBURST_FIRE_DAMAGE_RADIUS = 392;		//how far out from the center of the map the flameburst damage goes
float FLAMEBURST_FIRE_DAMAGE = 10;				//the amount of damage to do..damage is done every interval
float FLAMEBURST_FIRE_DAMAGE_INTERVAL = .5;		//how often it will damage the player while he's in the fire
string FLAMEBURST_FIRE_DAMAGE_TYPE = "fire";	//the type of damage to do

//--- dock constants
float BOSS_DOCK_BASE_TIME = 4;					//time to move the dock base
float BOSS_DOCK_ARM_TIME = 5;					//time to move the dock arm
float BOSS_DOCK_ARMLOCK_TIME = .5;				//time to move the arm locks
float BOSS_DOCK_WALKWAY_TIME = 4;				//time to move the walkway
float BOSS_DOCK_SCANNER_TIME = 1.5;				//time to move the scanner and arm lock segments
float BOSS_DOCK_SCANNER_DISTANCE = 30;			//distance to move the scanner segments
float BOSS_DOCK_ARMLOCK_DISTANCE = 8;			//distance to move the arm locks
float BOSS_DOCK_BASE_DISTANCE = 58;				//distance to move the base
float BOSS_DOCK_ARM_DISTANCE = 170;				//distance to move the arm
float BOSS_DOCK_WALKWAY_DISTANCE = 80;			//distance to move the walkway


//-----------------------------------------------------------
//-----------------------------------------------------------
//--- calculated value constants

float BOOST_BLINDSPOT_UPPER_ANGLE;				//this is 180 plus the BOOST_BLINDSPOT_TOLERANCE
float BOOST_BLINDSPOT_LOWER_ANGLE;				//this is 180 minus the BOOST_BLINDSPOT_TOLERANCE


//-----------------------------------------------------------
//-----------------------------------------------------------
//--- enumerated list values

//--- Boss states (order is important, 0 is the highest priority)
float BOSS_STATE_DEATH = 0;
float BOSS_STATE_PHASE_CHANGE = 1;
float BOSS_STATE_BROKEN = 2;
float BOSS_STATE_SCAN = 3;
float BOSS_STATE_BOOST = 4;
float BOSS_STATE_AIRLOCK = 5;
float BOSS_STATE_FLAMEBURST = 6;
float BOSS_STATE_CHASE_PLAYER = 7;
float BOSS_STATE_RESET = 10;

//--- sub states
float BROKEN_STATE_NONE = 10;
float BROKEN_STATE_START = 11;
float BROKEN_STATE_WAIT = 12;
float BROKEN_STATE_MOVE_TO_VENT = 13;
float BROKEN_STATE_AT_VENT = 14;
float BROKEN_STATE_POST = 15;

float SCAN_STATE_NONE = 20;
float SCAN_STATE_START = 21;
float SCAN_STATE_MOVE_TO_SAFETY = 22;
float SCAN_STATE_AT_SAFETY = 23;
float SCAN_STATE_POST = 24;

float BOOST_STATE_NONE = 30;
float BOOST_STATE_START = 31;
float BOOST_STATE_MOVE_TO_GOAL = 32;
float BOOST_STATE_AT_GOAL = 33;
float BOOST_STATE_POST = 34;

float PHASE_CHANGE_STATE_NONE = 40;
float PHASE_CHANGE_STATE_START = 41;
float PHASE_CHANGE_STATE_CINEMATIC = 42;
float PHASE_CHANGE_STATE_POST = 43;


//-----------------------------------------------------------
//-----------------------------------------------------------
//--- variables
float intBoss_CurrentPhase = 1;
float intBossMove_Speed;
float intBossAttack_BoostCounter = 0;
float intBossAttack_FlameburstCounter = 0;
float intBossAttack_AirlockCounter = 0;
float intBossAttack_ScanCounter = 0;
float intScanBeamTime;

float fltFlameburst_DoorTime;
float fltFlameburst_FireDelayTime;
float fltTauntFlameburst_Previous;
float fltTauntAirlock_Previous;
float fltTauntScan_Previous;
float fltTauntBoost_Previous;
float fltCinematicStageChange_AngularDistanceFromBase;

float boolBossState_IsUpdating;
float boolBossDamage_VentAllowed;
float boolBossMove_PlayerCanPosition;
float boolBossMove_GoToVent;
float boolBossMove_AtVent;
float boolBossAttack_Available;
float boolBossAttack_BoostAvailable;
float boolBossAttack_FlameburstAvailable;
float boolBossAttack_AirlockAvailable;
float boolBossAttack_ScanAvailable;
float boolVent_Active;
float boolVent_Available = 1;
float boolScan_Active;
float boolPhaseCinematic_Active;
float boolBossDock_BaseExtended;
float boolBossDock_CinematicRetract = 0;

vector vecBossPositionGoal;
vector vecBossBoostGoal;
vector vecCinematicMunroNodeOrigin;
vector vecCinematicLurokNodeOrigin;

float enumBossState_Current;
float enumBossState_PhaseChange;
float enumBossState_Broken;
float enumBossState_Scan;
float enumBossState_Boost;

entity cinematicArm_Intro;
entity cinematicArm_End;

float g_boolFlameBurstActive;
float float_bossInVehicle;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void	coop_bindAndHide(entity e1,entity e2);
void	coop_rigBossAttackClosest();
float	coop_checkPlayerIsDeath();
void	coop_hideRig();
void	coop_showRig();
void	coop_endLevel();
vector	vector_rigRestoreLocation;
entity	eBossHatesMe;
float	float_cinematicDA_active;


//===================================================================================================================================================
//===================================================================================================================================================
//  INCLUDES
//===================================================================================================================================================
//===================================================================================================================================================
#include "coop_mod/maps/main.scr"
#include "coop_mod/maps/global/global_common.scr"
#include "maps/global_scripts/global_math.scr"
#include "coop_mod/maps/global/global_cinematicFX.scr"
#include "maps/global_scripts/global_acceleratedMovement.scr"
#include "maps/global_scripts/global_archetype.scr"
#include "coop_mod/maps/missions/9/m9l2_cin.scr"


//===================================================================================================================================================
//===================================================================================================================================================
//  MAIN FUNCTION
//===================================================================================================================================================
//===================================================================================================================================================

/*
"targetname" "cinematicWeaponTetryon"
"origin" "1232.52 1914.16 23.00"
"angle" "148"
"model" "models/weapons/worldmodel-tetryon.tik"
"classname" "script_model"
*/

//MP SPAWN: 449 24 469 :64

//---------------------
void main()
//---------------------
{
	globalCoop_main_camFadeOut(.1);
	$boss_merc.ai_off();
	$boss_merc.hide();
	$boss_merc.notsolid();
//INIZIAL RIG LOCATION AT FIRSTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
	vector_rigRestoreLocation = '1152 1152 528';
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	coop_string_nextMapToCheck			= "m10l1-romulan_installation";//set the map we gona load next while we are in testmode
//Set spawnangles for this level
	coop_float_spawnAngle0 				= 270;
	coop_vector_spawnOrigin8 			= '1257 2468 0';
	coop_vector_spawnOrigin7 			= '1190 2468 0';
	coop_vector_spawnOrigin6 			= '1130 2468 0';
	coop_vector_spawnOrigin5 			= '1070 2468 0';
	coop_vector_spawnOrigin4 			= '1257 2400 0';
	coop_vector_spawnOrigin3 			= '1190 2400 0';
	coop_vector_spawnOrigin2 			= '1130 2400 0';
	coop_vector_spawnOrigin1 			= '1070 2400 0';
//Definie Objective
	coop_string_objectiveItem1			= "DefeatKlingonBoss";
//definie weapons
	coop_string_weapon8	= "models/weapons/worldmodel-GrenadeLauncher.tik";
	coop_string_weapon7	= "models/weapons/worldmodel-CompressionRifle.tik";
	coop_string_weapon6 = "models/weapons/worldmodel-Tricorder-stx.tik";
	coop_string_weapon5 = "models/weapons/worldmodel-Batleth.tik";
	coop_string_weapon4 = "models/weapons/worldmodel-Phaser-stx.tik";
	coop_string_weapon3 = "models/weapons/worldmodel-FieldAssaultRifle.tik";
	coop_string_weapon2 = "models/weapons/worldmodel-photon.tik";
	coop_string_weapon1	= "models/weapons/worldmodel-BurstRifle.tik";
//Start the Co-Op Script
	globalCoop_main();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	//--- setup sky portal
	//$sky.rendereffects( "+skyorigin" );
	$world.entity_fade_dist( 80000 );
	
	//--- setup the boss
	setupArena();
	setupBoss();
	setupVariables();

	waitForPlayer();
	if(!cvar_bool_multiplayer){
	//--- load the objectives
		$player.loadobjectives( "m9l2-klingon_base" );
	}
//Set viewModes
	$world.clearAvailableViewModes();
	$world.addAvailableViewMode( "structuralintegrity" );
	
	//--- intro cinematic
	thread cinematicArm_Intro_Start();
}


//===================================================================================================================================================
//===================================================================================================================================================
//  SETUP FUNCTIONS
//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// setupArena
// setup the arena
//---------------------
void setupArena()
{
//--- set the soundtrack
	soundtrack( "music/m9l2-klingon_base.mus" );
//Do that stuff only while we are in mp...
//Do that stuff only while we are in mp...
//Do that stuff only while we are in mp...
	if(cvar_bool_multiplayer){//Multiplayer
	//spawn Class Selection
		thread globalCoop_class_setup("HeavyWeapons",'1234 -160 -2');
		thread globalCoop_class_setup("Technician",'1136 -160 -2');
		thread globalCoop_class_setup("Medic",'1056 -160 -2');
//REMOVE THE DEATH SPACE MUNRO
		$deathMunro.remove();
		spawn( "func_spawn","targetname","poopyIce","origin","4575 738 -40","modelName","fx/fx-explosion-ice-gas-large.tik","angles","90 0 0");
		wait(.05);
		$poopyIce.scale(.08);
	}

	//--- load camera paths
	//cam.load( "m9l2_end1" );
	//cam.load( "m9l2_end2" );
	//cam.load( "m9l2_end3" );

	//--- AI
	globalCommon_AiDummyHide( $munro );
	$munro.useActorWeapon( "none" );
	
	//--- set the starting states of the arena switches
	arenaSwitchMoveBoss_Display_BossInControl();
	arenaSwitchFireVent_Display_Ready();
	$switchMoveBoss_IndicatorLight.rotateY( 360 );
	$switchMoveBoss_IndicatorLight.hide();
	$switchActivateVent_IndicatorLight.rotateX( 360 );
	$switchActivateVent_IndicatorLight.hide();
	
	//--- big vent flame damage stuff
	$triggerVentFire_Damage.nottriggerable();
	$ventFire.anim( "idle" );
	
	//--- flameburst attack stuff
	$world.light_lightstyle( "doorFlameburst_WarningBeacon_LightRed" , "aaaaaaaaaaaaaaaaaaaaaaaaaab" , 0 );
	
	thread globalAccelMove_RelativeY( $doorFlameburst_WarningBeacon, -8, .1, "none", "" );
	
	$ventFlameburst.anim( "idle" );
	$ventFlameburst.hide();
	
	//--- Scan beam stuff
	$scannerScan_Beam.bind( $scannerScan_Base );
	$scannerScan_PositionMarker.bind( $scannerScan_Base );
	$scannerScan_Beam.hide();

	//--- airlock attack stuff
	$world.light_lightstyle( "doorAirlock1_RimLights_LightRed" , "aaaaaaaaaaaaaaaaaaaaaaaaaab" , 0 );
	$world.light_lightstyle( "doorAirlock2_RimLights_LightRed" , "aaaaaaaaaaaaaaaaaaaaaaaaaab" , 0 );
	$world.light_lightstyle( "doorAirlock3_RimLights_LightRed" , "aaaaaaaaaaaaaaaaaaaaaaaaaab" , 0 );
	$world.light_lightstyle( "doorAirlock4_RimLights_LightRed" , "aaaaaaaaaaaaaaaaaaaaaaaaaab" , 0 );
	
	$doorAirlock1_RimLights_On.hide();
	$doorAirlock2_RimLights_On.hide();
	$doorAirlock3_RimLights_On.hide();
	$doorAirlock4_RimLights_On.hide();

	coop_bindAndHide($doorAirlock1_AlertBeacon1_LightCone,$doorAirlock1_AlertBeacon1_Base);
	coop_bindAndHide($doorAirlock1_AlertBeacon2_LightCone,$doorAirlock1_AlertBeacon2_Base);
	coop_bindAndHide($doorAirlock2_AlertBeacon1_LightCone,$doorAirlock2_AlertBeacon1_Base);
	coop_bindAndHide($doorAirlock2_AlertBeacon2_LightCone,$doorAirlock2_AlertBeacon2_Base);
	coop_bindAndHide($doorAirlock3_AlertBeacon1_LightCone,$doorAirlock3_AlertBeacon1_Base);
	coop_bindAndHide($doorAirlock3_AlertBeacon2_LightCone,$doorAirlock3_AlertBeacon2_Base);
	coop_bindAndHide($doorAirlock4_AlertBeacon1_LightCone,$doorAirlock4_AlertBeacon1_Base);
	coop_bindAndHide($doorAirlock4_AlertBeacon2_LightCone,$doorAirlock4_AlertBeacon2_Base);
	wait( .1 );
	
	thread globalAccelMove_RelativeY( $doorAirlock1_AlertBeacon1_Base, -24, .1, "none", "" );
	thread globalAccelMove_RelativeY( $doorAirlock1_AlertBeacon2_Base, -24, .1, "none", "" );
	thread globalAccelMove_RelativeY( $doorAirlock2_AlertBeacon1_Base, -24, .1, "none", "" );
	thread globalAccelMove_RelativeY( $doorAirlock2_AlertBeacon2_Base, -24, .1, "none", "" );
	thread globalAccelMove_RelativeY( $doorAirlock3_AlertBeacon1_Base, -24, .1, "none", "" );
	thread globalAccelMove_RelativeY( $doorAirlock3_AlertBeacon2_Base, -24, .1, "none", "" );
	thread globalAccelMove_RelativeY( $doorAirlock4_AlertBeacon1_Base, -24, .1, "none", "" );
	thread globalAccelMove_RelativeY( $doorAirlock4_AlertBeacon2_Base, -24, .1, "none", "" );
	
	//--- onxxx objects
	thread globalCommon_OnUse( $switchMoveBoss_Trigger, "arenaSwitchMoveBoss_Execute" );
	thread globalCommon_OnUse( $switchActivateVent_Trigger, "arenaSwitchFireVent_Execute" );
	
	//--- setup archetypes
	globalArchetype_Setup( $archetypeSwitchMoveBoss, "KlingonCraneManualOverride" );
	globalArchetype_Setup( $archetypeSwitchActivateVent, "KlingonFireVentControl" );
	
	//--- hide the cinematic tetryon gun
	$cinematicWeaponTetryon.hide();
	$cinematicWeaponTetryon.notsolid();
	
	$bossRepairModeMovementClip.bind( $boss_rig );
	$boss_merc.notSolid();
}


//---------------------
// setupBoss
// setup the boss
//---------------------
void setupBoss()
{
	//--- bind the boss together
	$boss_rig.bind( $boss_rig_mover );
	$boss_rig_top.bind( $boss_rig_mover );
	$boss_rig_watch.bind( $boss_rig_mover );

	//--- make the rig and top hidden and notsolid
 	$boss_rig.hide(); //TEST WITH NOTSOLID AND VISIBLE
	$boss_rig.notsolid();
	$boss_rig_top.hide();
	$boss_rig_top.notsolid();
	
	//--- make the script object not solid
	$boss_rig_mover.notsolid();
	
	//--- setup the forcefield
	$boss_rig_forcefield.notsolid();
	$boss_rig_forcefield.hide();
	
	//--- bind together the docking clamp
	$bossDock_RightScanner.bind( $bossDock_RightScanner_SubBase3 );
	$bossDock_RightScanner_SubBase3.bind( $bossDock_RightScanner_SubBase2 );
	$bossDock_RightScanner_SubBase2.bind( $bossDock_RightScanner_SubBase1 );
	$bossDock_RightScanner_SubBase1.bind( $bossDock_RightScanner_Base2 );
	$bossDock_RightScanner_Base2.bind( $bossDock_RightScanner_Base1 );
	$bossDock_RightScanner_Base1.bind( $bossDock_Arm );

	$bossDock_LeftScanner.bind( $bossDock_LeftScanner_SubBase3 );
	$bossDock_LeftScanner_SubBase3.bind( $bossDock_LeftScanner_SubBase2 );
	$bossDock_LeftScanner_SubBase2.bind( $bossDock_LeftScanner_SubBase1 );
	$bossDock_LeftScanner_SubBase1.bind( $bossDock_LeftScanner_Base2 );
	$bossDock_LeftScanner_Base2.bind( $bossDock_LeftScanner_Base1 );
	$bossDock_LeftScanner_Base1.bind( $bossDock_Arm );
	
	$bossDock_ArmLock_Top.bind( $bossDock_Base );
	$bossDock_ArmLock_Bottom.bind( $bossDock_Base );
	
	$bossDock_Walkway.bind( $bossDock_Arm );
	$bossDock_Arm.bind( $bossDock_Base );

	//--- put the scanners in their starting positions
	$bossDock_RightScanner_SubBase3.time( .05 );
	$bossDock_RightScanner_SubBase2.time( .05 );
	$bossDock_RightScanner_SubBase1.time( .05 );
	$bossDock_RightScanner_Base2.time( .05 );
	$bossDock_RightScanner_Base1.time( .05 );
	$bossDock_RightScanner.time( .05 );
	$bossDock_LeftScanner_SubBase3.time( .05 );
	$bossDock_LeftScanner_SubBase2.time( .05 );
	$bossDock_LeftScanner_SubBase1.time( .05 );
	$bossDock_LeftScanner_Base2.time( .05 );
	$bossDock_LeftScanner_Base1.time( .05 );
	$bossDock_LeftScanner.time( .05 );
	$bossDock_ArmLock_Top.time( .05 );
	$bossDock_ArmLock_Bottom.time( .05 );
	
	$bossDock_RightScanner_SubBase3.moveBackward( BOSS_DOCK_SCANNER_DISTANCE );
	$bossDock_LeftScanner_SubBase3.moveBackward( BOSS_DOCK_SCANNER_DISTANCE );
	waitFor( $bossDock_LeftScanner_SubBase3 );

	$bossDock_RightScanner_SubBase2.moveBackward( BOSS_DOCK_SCANNER_DISTANCE );
	$bossDock_LeftScanner_SubBase2.moveBackward( BOSS_DOCK_SCANNER_DISTANCE );
	waitFor( $bossDock_LeftScanner_SubBase2 );

	$bossDock_RightScanner_Base2.moveBackward( BOSS_DOCK_SCANNER_DISTANCE );
	$bossDock_LeftScanner_Base2.moveBackward( BOSS_DOCK_SCANNER_DISTANCE );
	waitFor( $bossDock_LeftScanner_Base2 );

	//$bossDock_RightScanner_Base1.rotateYdown( 10 );
	//$bossDock_LeftScanner_Base1.rotateYup( 10 );
	$bossDock_ArmLock_Top.moveDown( BOSS_DOCK_ARMLOCK_DISTANCE );
	$bossDock_ArmLock_Bottom.moveUp( BOSS_DOCK_ARMLOCK_DISTANCE );
	$bossDock_RightScanner_SubBase1.rotateYup( 40 );
	$bossDock_LeftScanner_SubBase1.rotateYdown( 40 );
	waitFor( $bossDock_LeftScanner_SubBase1 );

	//--- reset the times for the dock
	$bossDock_RightScanner_SubBase3.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner_SubBase2.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner_SubBase1.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner_Base2.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner_Base1.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_SubBase3.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_SubBase2.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_SubBase1.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_Base2.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_Base1.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_Walkway.time( BOSS_DOCK_WALKWAY_TIME );
	$bossDock_ArmLock_Top.time( BOSS_DOCK_ARMLOCK_TIME );
	$bossDock_ArmLock_Bottom.time( BOSS_DOCK_ARMLOCK_TIME );
	$bossDock_Arm.time( BOSS_DOCK_ARM_TIME );
	$bossDock_Base.time( BOSS_DOCK_BASE_TIME );
	
	//--- setup the ground merc
	$boss_merc.killthread( "bossThink_MercDeath" );
}


//---------------------
// setupVariables
// setup the starting values on variables
//---------------------
void setupVariables()
{
	intBossMove_Speed = BOSS_MOVE_SPEED_NORMAL;		//initialize his starting movement speed to normal
	
	boolBossState_IsUpdating = FALSE;
	boolBossDamage_VentAllowed = FALSE;
	boolBossMove_PlayerCanPosition = FALSE;
	boolBossMove_GoToVent = FALSE;
	boolBossMove_AtVent = FALSE;
	boolBossAttack_Available = TRUE;
	boolBossAttack_BoostAvailable = TRUE;			//becomes available in second phase
	boolBossAttack_FlameburstAvailable = TRUE;		//available from the start
	boolBossAttack_AirlockAvailable = FALSE;		//available in the third phase
	boolBossAttack_ScanAvailable = FALSE;		//available in the second phase
	boolVent_Active = FALSE;
	boolScan_Active = FALSE;
	boolPhaseCinematic_Active = FALSE;
	boolBossDock_BaseExtended = FALSE;

	fltFlameburst_DoorTime = FLAMEBURST_DOOR_TIME_PHASE1;
	fltFlameburst_FireDelayTime = FLAMEBURST_DOOR_FIRE_DELAY_PHASE1;

	enumBossState_Current = BOSS_STATE_CHASE_PLAYER;
	enumBossState_PhaseChange = PHASE_CHANGE_STATE_NONE;
	enumBossState_Broken = BROKEN_STATE_NONE;
	enumBossState_Scan = SCAN_STATE_NONE;
	enumBossState_Boost = BOOST_STATE_NONE;
	
	//--- calculated constants
	BOOST_BLINDSPOT_UPPER_ANGLE = 180 + BOOST_BLINDSPOT_TOLERANCE;
	BOOST_BLINDSPOT_LOWER_ANGLE = 180 - BOOST_BLINDSPOT_TOLERANCE;
	
	//--- store the node for munro for stage change cinematics
	vecCinematicMunroNodeOrigin = $nodeMunro_StageCinematic.getOrigin();
	vecCinematicLurokNodeOrigin = $nodeLurok_StageCinematic.getOrigin();
}

//===================================================================================================================================================
//===================================================================================================================================================
//  BOSS THINK FUNCTIONS
//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// bossThink_StateEvalLoop
// the master loop that evaluates the state the boss
// is in and performs the desired actions based on
// those states
//---------------------
void bossThink_StateEvalLoop()
{
	//--- local variables
	float enumState;
	float enumSubState;
	float intAirlockDoor;
	float temp;
	
	enumState = -1;
	
	//print( "STATE EVAL CYCLE: Starting cycle\n" );
	
	//--- cycle throught the state eval loop until the rig is dead
	while( enumState != BOSS_STATE_DEATH )
	{
		//--- evaluate the state and perform the correct action
		
		//print( "STATE EVAL CYCLE: Current state: " + enumState + "\n" );
		
		//----------------------------------------
		//--- Phase change state
		//----------------------------------------
		if( enumState == BOSS_STATE_PHASE_CHANGE )
		{
			//--- evaluate the substate
			enumSubState = bossGet_StatePhaseChange();
			
			//--- run the corresponding function for the sub state
			if( enumSubState == PHASE_CHANGE_STATE_NONE )
			{
				//--- set the state to chasing the player
				bossSet_State( BOSS_STATE_RESET );
			}
			else if( enumSubState == PHASE_CHANGE_STATE_START )
			{
				//print( "STATE EVAL CYCLE: Start phase change\n" );
				
				//--- call the Phase change start function
                bossAction_PhaseChangeState_Start();
			}
			else if( enumSubState == PHASE_CHANGE_STATE_CINEMATIC )
			{
				//--- call the Phase change cinematic function
                bossAction_PhaseChangeState_Cinematic();
			}
			else if( enumSubState == PHASE_CHANGE_STATE_POST )
			{
				//--- call the Phase change pose function
                bossAction_PhaseChangeState_Post();
			}
		}
		//----------------------------------------
		//--- Broken state
		//----------------------------------------
		else if( enumState == BOSS_STATE_BROKEN )
		{
			//--- evaluate the substate
			enumSubState = bossGet_StateBroken();
			
			//--- run the corresponding function for the sub state
			if( enumSubState == BROKEN_STATE_NONE )
			{
				//--- set the state to chasing the player
				bossSet_State( BOSS_STATE_RESET );
			}
			else if( enumSubState == BROKEN_STATE_START )
			{
				//print( "STATE EVAL CYCLE: Start broken state\n" );
				
				//--- call the broken start function
				bossAction_BrokenState_Start();
			}
			else if( enumSubState == BROKEN_STATE_WAIT )
			{
				//--- do nothing while waiting
				bossAction_BrokenState_Wait();
			}
			else if( enumSubState == BROKEN_STATE_MOVE_TO_VENT )
			{
				//--- call the broken move to vent function
				bossAction_BrokenState_MoveToVent();
			}
			else if( enumSubState == BROKEN_STATE_AT_VENT )
			{
				//--- call the broken at vent function
				bossAction_BrokenState_AtVent();
			}
			else if( enumSubState == BROKEN_STATE_POST )
			{
				//--- call the broken post
				bossAction_BrokenState_Post();
			}
		}
		//----------------------------------------
		//--- Scan state
		//----------------------------------------
		else if( enumState == BOSS_STATE_SCAN )
		{
			//--- evaluate the substate
			enumSubState = bossGet_StateScan();
			
			//--- run the corresponding function for the sub state
			if( enumSubState == SCAN_STATE_NONE )
			{
				//print( "STATE EVAL CYCLE: Start scan attack\n" );
				
				//--- set the state to chasing the player
				bossSet_State( BOSS_STATE_RESET );
			}
			else if( enumSubState == SCAN_STATE_START )
			{
				//--- call the scan start function
				bossAction_ScanState_Start();
			}
			else if( enumSubState == SCAN_STATE_MOVE_TO_SAFETY )
			{
				//--- call the scan move to saftey function
				bossAction_ScanState_MoveToSafety();
			}
			else if( enumSubState == SCAN_STATE_AT_SAFETY )
			{
				//--- call the scan at safety function
				bossAction_ScanState_AtSafety();
			}
			else if( enumSubState == SCAN_STATE_POST )
			{
				//--- call the scan post
				bossAction_ScanState_Post();
				
			}			
		}
		//----------------------------------------
		//--- Boost state
		//----------------------------------------
		else if( enumState == BOSS_STATE_BOOST )
		{
			//--- evaluate the substate
			enumSubState = bossGet_StateBoost();
			
			//--- run the corresponding function for the sub state
			if( enumSubState == BOOST_STATE_NONE )
			{
				//--- set the state to chasing the player
				bossSet_State( BOSS_STATE_RESET );
			}
			else if( enumSubState == BOOST_STATE_START )
			{
				//print( "STATE EVAL CYCLE: Start boost attack\n" );
				
				//--- call the boost start function
                bossAction_BoostState_Start();
			}
			else if( enumSubState == BOOST_STATE_MOVE_TO_GOAL )
			{
				//--- call the boost move to goal function
                bossAction_BoostState_MoveToGoal();
			}
			else if( enumSubState == BOOST_STATE_AT_GOAL )
			{
				//--- call the boost at goal function
                bossAction_BoostState_AtGoal();
			}
			else if( enumSubState == BOOST_STATE_POST )
			{
				//--- call the boost post
                bossAction_BoostState_Post();				
			}			
		}
		//----------------------------------------
		//--- Airlock state
		//----------------------------------------
		else if( enumState == BOSS_STATE_AIRLOCK )
		{
			//print( "STATE EVAL CYCLE: Start airlock attack\n" );
			
			//-- SK:  Altering Boss flow -- Boss will no longer
			// remove an airlock like this -- instead will drop 2 at stage 2
			// and the other 2 at stage 3

			//--- pick the airlock door to open
			intAirlockDoor = arenaAirlock_PickAirlock();
			
			//--- call the airlock function
			thread arenaAirlock_OpenAirlock( intAirlockDoor );

        	//--- boss attack warning indicator taunt
        	thread bossAction_Taunt( BOSS_STATE_AIRLOCK );

			//--- set the state to chasing the player
			bossSet_State( BOSS_STATE_RESET );
		}
		//----------------------------------------
		//--- Flameburst state
		//----------------------------------------
		else if( enumState == BOSS_STATE_FLAMEBURST )
		{
			//print( "STATE EVAL CYCLE: Start flameburst attack\n" );
			
			//--- call the flameburst function
			thread arenaFlameburst_Activate();

        	//--- boss attack warning indicator taunt
        	thread bossAction_Taunt( BOSS_STATE_FLAMEBURST );
        	
        	//--- tell the AI that a flameburst is starting
        	$boss_rig.usebehaviorpackage( "rigboss_flame" );

			//--- set the state to chasing the player
			bossSet_State( BOSS_STATE_RESET );
		}
		//----------------------------------------
		//--- Chase Player state
		//----------------------------------------
		else
		{
        	//--- move the boss
			entity e;
			e = globalCoop_return_playerClosestPreferActive($boss_rig);
			vector vOri;
			vOri = e.getOrigin();
        	temp = bossAction_MoveRequest(vOri, BOSS_MOVE_TOLERANCE_NORMAL );
		}
		
		wait( BOSS_EVAL_STATE_CYCLE_TIME );

		//--- get the current state of the boss
		enumState = bossGet_State();
	}
	
	bossAction_MoveStop();
	
	print( "BOSS STATE EVAL:  DEATH OF RIG!!\n" );
	//centerprint( "BOSS STATE EVAL:  DEATH OF RIG!!" );
}


//---------------------
// bossThink_AttackEvalLoop
// This loop evaluates which of the script controlled
// attacks would be best to perform
//---------------------
void bossThink_AttackEvalLoop()
{
	//--- local variables
	float enumState;
	float boolDoAttack;
	float boolSkipEvalCycle;	//because there's no frikkin' continue command in our scripting language, so....HACK HACK HACK!!!!
	
	enumState = -1;

	//--- cycle throught the state eval loop until the rig is dead
	while( enumState != BOSS_STATE_DEATH )
	{
		//--- get the current state of the boss
		enumState = bossGet_State();
	
		//--- set the skip cycle flag to false
		boolSkipEvalCycle = FALSE;
		
		//--- if the boss is allowed to attack, evaluate all attacks
		if(	boolBossAttack_Available == TRUE )
		{
			//print( "ATTACK EVAL CYCLE: starting\n" );
    		//print( "ATTACK EVAL: ************************************************\n" );
    		//print( "ATTACK EVAL: **************   COUNTER CHECK   ***************\n" );
			
			//-------------------------------------------
			//--- SCAN EVALUATION
			//-------------------------------------------
			if( boolBossAttack_ScanAvailable == TRUE )
			{
				//--- evaluate conditions for a scan attack
				boolDoAttack = bossThink_AttackEval_Scan();

				//print( "ATTACK EVAL: scan counter: " + intBossAttack_ScanCounter + "\n" );
				
				//--- if the evaluation came back as true, set the attack state
				if( boolDoAttack == TRUE )
				{
					//--- set the substate and state
					bossSet_StateScan( SCAN_STATE_START );
					bossSet_State( BOSS_STATE_SCAN );
					
					//--- launch the reset function
					thread bossThink_AttackEval_ScanReset();
					
					//--- set the set the skip cycle flag
					boolSkipEvalCycle = TRUE;
				}
			}

			if( boolSkipEvalCycle == FALSE )
			{
        		//-------------------------------------------
        		//--- BOOST EVALUATION
        		//-------------------------------------------
        		if( boolBossAttack_BoostAvailable == TRUE )
        		{
        			//--- evaluate conditions for a boost attack
    				boolDoAttack = bossThink_AttackEval_Boost();

            		//print( "ATTACK EVAL: boost counter: " + intBossAttack_BoostCounter + "\n" );
    				
    				//--- if the evaluation came back as true, set the attack state
    				if( boolDoAttack == TRUE )
    				{
    					//--- set the substate and state
    					bossSet_StateBoost( BOOST_STATE_START );
    					bossSet_State( BOSS_STATE_BOOST );
    					
    					//--- launch the reset function
    					thread bossThink_AttackEval_BoostReset();
    					
    					//--- set the set the skip cycle flag
    					boolSkipEvalCycle = TRUE;
    				}
        		}
        	}

			if( boolSkipEvalCycle == FALSE )
			{
    			//-------------------------------------------
    			//--- FLAMEBURST EVALUATION
    			//-------------------------------------------
    			if( boolBossAttack_FlameburstAvailable == TRUE )
    			{
    				//--- evaluate conditions for a flameburst attack	
    				boolDoAttack = bossThink_AttackEval_Flameburst();

            		//print( "ATTACK EVAL: flameburst counter: " + intBossAttack_FlameburstCounter + "\n" );
    				
    				//--- if the evaluation came back as true, set the attack state
    				if( boolDoAttack == TRUE )
    				{
    					//--- set the substate and state
    					bossSet_State( BOSS_STATE_FLAMEBURST );
    					
    					//--- launch the reset function
    					thread bossThink_AttackEval_FlameburstReset();

    					//--- set the set the skip cycle flag
    					boolSkipEvalCycle = TRUE;
    				}
    			}
    		}

			if( boolSkipEvalCycle == FALSE )
			{
    			//-------------------------------------------
    			//--- AIRLOCK EVALUATION
    			//-------------------------------------------
    			if( boolBossAttack_AirlockAvailable == TRUE )
    			{
    				//--- evaluate conditions for a airlock attack	
    				boolDoAttack = bossThink_AttackEval_Airlock();

            		//print( "ATTACK EVAL: airlock counter: " + intBossAttack_AirlockCounter + "\n" );
            		    				
    				//--- if the evaluation came back as true, set the attack state
    				if( boolDoAttack == TRUE )
    				{
    					//--- set the substate and state
    					bossSet_State( BOSS_STATE_AIRLOCK );
    					
    					//--- launch the reset function
    					thread bossThink_AttackEval_AirlockReset();
    				}
    			}
    		}
			
		}
		
		//--- wait the cycle time
		wait( BOSS_EVAL_ATTACK_CYCLE_TIME );	
	}

}


//------------------------------------
//--- SCAN EVALUATION
//------------------------------------

//---------------------
// bossThink_AttackEval_Scan
// returns - float, TRUE if an attack should be done, FALSE otherwise
// Evaluate whether a scan should be done
//---------------------
float bossThink_AttackEval_Scan()
{
	//--- variables
	float intDistance;

	if( g_boolFlameBurstActive == TRUE )
	{
		return( FALSE );
	}

	//--- get the angular distance between the rig and the player
	intDistance = globalMath_GetXYDistance( eBossHatesMe.getorigin(), '1152 1152 708' );

	//--- check the angular distance against the upper and lower boost blindspot angles
	if( intDistance >= 400 )
	{
		//--- the player falls within the blindspot
		intBossAttack_ScanCounter ++;
		
		//--- check if the counter's been breached
		if( intBossAttack_ScanCounter >= BOSS_SCAN_COUNTER_LIMIT )
		{
			//--- reset the counter and return true
			intBossAttack_ScanCounter = 0;
			return( TRUE );
		}
	}
	
	//--- return false otherwise		
	return( FALSE );
}


//---------------------
// bossThink_AttackEval_ScanReset
// This function deactivates the scan attack
// for the specified amount of time
//---------------------
void bossThink_AttackEval_ScanReset()
{
	//--- turn off the attack
	boolBossAttack_ScanAvailable = FALSE;
	wait( BOSS_SCAN_RESET_TIME );
	
	//--- turn on the attack
	boolBossAttack_ScanAvailable = TRUE;
}


//------------------------------------
//--- BOOST EVALUATION
//------------------------------------

//---------------------
// bossThink_AttackEval_Boost
// returns - float, TRUE if an attack should be done, FALSE otherwise
// Evaluate whether a boost should be done
//---------------------
float bossThink_AttackEval_Boost()
{
	//--- variables
	float intAngularDistance;
	
	//--- get the angular distance between the rig and the player
	entity e;
	e = globalCoop_return_playerClosestPreferActive($boss_rig);
	vector vOri;
	vOri = e.getOrigin();
	intAngularDistance = commonGet_AngularDistance(vOri, $boss_rig.getorigin() );

	//--- check the angular distance against the upper and lower boost blindspot angles
	if( intAngularDistance <= BOOST_BLINDSPOT_UPPER_ANGLE && intAngularDistance >= BOOST_BLINDSPOT_LOWER_ANGLE )
	{
		//--- the player falls within the blindspot
		intBossAttack_BoostCounter ++;
		
		//--- check if the counter's been breached
		if( intBossAttack_BoostCounter >= BOSS_BOOST_COUNTER_LIMIT )
		{
			//--- reset the counter and return true
			intBossAttack_BoostCounter = 0;
			return( TRUE );
		}
	}
	
	//--- return false otherwise		
	return( FALSE );
}


//---------------------
// bossThink_AttackEval_BoostReset
// This function deactivates the boost attack
// for the specified amount of time
//---------------------
void bossThink_AttackEval_BoostReset()
{
	//--- turn off the attack
	boolBossAttack_BoostAvailable = FALSE;
	wait( BOSS_BOOST_RESET_TIME );
	
	//--- turn on the attack
	boolBossAttack_BoostAvailable = TRUE;
}


//float BOSS_AIRLOCK_COUNTER_LIMIT = 10;		//the counter to check how long the player is staying in


//------------------------------------
//--- FLAMEBURST EVALUATION
//------------------------------------

//---------------------
// bossThink_AttackEval_Flameburst
// returns - float, TRUE if an attack should be done, FALSE otherwise
// Evaluate whether a flameburst should be done
//---------------------
float bossThink_AttackEval_Flameburst()
{
	//--- variables
	float intDistance;
	
	//--- get the angular distance between the rig and the player
	//intDistance = globalMath_GetXYDistance( $player.getorigin(), '1152 1152 708' );
//GET THE PLAYER THE BOSS IS CURRENTLY IN HATE WITH
	vector vOri;
	if(doesEntityExist(eBossHatesMe)){
		vOri = eBossHatesMe.getOrigin();
	}else{
		entity e;
		e = globalCoop_return_playerClosestPreferActive($center);
		vOri = e.getOrigin();
	}
	intDistance = globalMath_GetXYDistance(vOri,'1152 1152 708');
	
	//print( "FLAMEBURST EVAL: distance: " + intDistance + "\n" );

	//--- check the angular distance against the upper and lower boost blindspot angles
	if( intDistance < 400 )
	{
		//print( "FLAMEBURST EVAL: upping counter\n" );
		
		//--- the player falls within the blindspot
		intBossAttack_FlameburstCounter ++;
		
		//--- check if the counter's been breached
		if( intBossAttack_FlameburstCounter >= BOSS_FLAMEBURST_COUNTER_LIMIT )
		{
			//--- reset the counter and return true
			intBossAttack_FlameburstCounter = 0;
			return( TRUE );
		}
	}
	
	//--- return false otherwise		
	return( FALSE );
}


//---------------------
// bossThink_AttackEval_FlameburstReset
// This function deactivates the flameburst attack
// for the specified amount of time
//---------------------
void bossThink_AttackEval_FlameburstReset()
{
	//--- turn off the attack
	boolBossAttack_FlameburstAvailable = FALSE;
	wait( BOSS_FLAMEBURST_RESET_TIME );
	
	//--- turn on the attack
	if( intBoss_CurrentPhase < 3 )
	{
		boolBossAttack_FlameburstAvailable = TRUE;
	}
}


//------------------------------------
//--- AIRLOCK EVALUATION
//------------------------------------

//---------------------
// bossThink_AttackEval_Airlock
// returns - float, TRUE if an attack should be done, FALSE otherwise
// Evaluate whether a airlock should be done
//---------------------
float bossThink_AttackEval_Airlock()
{
	//--- variables
	float intDistance;
	
	//--- get the angular distance between the rig and the player
	intDistance = globalMath_GetXYDistance( eBossHatesMe.getorigin(), '1152 1152 708' );

	//--- check the angular distance against the upper and lower boost blindspot angles
	if( intDistance >= 800 )
	{
		//--- the player falls within the blindspot
		intBossAttack_AirlockCounter ++;
		
		//--- check if the counter's been breached
		if( intBossAttack_AirlockCounter >= BOSS_AIRLOCK_COUNTER_LIMIT )
		{
			//--- reset the counter and return true
			intBossAttack_AirlockCounter = 0;
			return( TRUE );
		}
	}
	
	//--- return false otherwise		
	return( FALSE );
}


//---------------------
// bossThink_AttackEval_AirlockReset
// This function deactivates the airlock attack
// for the specified amount of time
//---------------------
void bossThink_AttackEval_AirlockReset()
{
	//--- turn off the attack
	boolBossAttack_AirlockAvailable = FALSE;
	wait( BOSS_FLAMEBURST_RESET_TIME );
	
	//--- turn on the attack
	boolBossAttack_AirlockAvailable = TRUE;
}


//---------------------
// bossThink_MercDeath
// When the merc out of the rig dies
//---------------------
void bossThink_MercDeath()
{
	//--- set objective
	if(!cvar_bool_multiplayer){
		$player.setobjectivecomplete( "DefeatKlingonBoss", 1 );
	}else{
		globalCoop_objectives_update("complete",1,1);
	}
	$boss_merc.missionobjective( 0 );
	wait( 2 );
	//IF SP AND PLAYER IS DEATH:LEAVE THIS FUNCTION
	if(coop_checkPlayerIsDeath()){return;}
	
	//--- dialog to enterprise
	
	//Munro to Enterprise. Omag just left the station. 
	globalCoop_dialog_play(globalCoop_return_entityE1OrE2(globalCoop_return_playerClosestPreferActive($sydney),$munro),"m9l2/munro_omagleft.mp3", 1, 20000, 1);
	wait( .2 );

	//IF SP AND PLAYER IS DEATH:LEAVE THIS FUNCTION
	if(coop_checkPlayerIsDeath()){return;}
	
	//Thank you, Lieutenant. We just locked on him. We're tracking him. 
	globalCoop_dialog_play($picard,"m9l2/picard_locked.mp3", 1, 20000, 1);
	wait( .2 );

	//IF SP AND PLAYER IS DEATH:LEAVE THIS FUNCTION
	if(coop_checkPlayerIsDeath()){return;}
	
	//Munro to Sydney. Pick me up immediately!
	globalCoop_dialog_play(globalCoop_return_entityE1OrE2(globalCoop_return_playerClosestPreferActive($sydney),$munro),"m9l2/munro_pickimm.mp3", 1, 20000, 1);
	wait( .2 );

	//IF SP AND PLAYER IS DEATH:LEAVE THIS FUNCTION
	if(coop_checkPlayerIsDeath()){return;}
	
	//Coming right now!
	globalCoop_dialog_play($sydney,"m9l2/syd_rightnow.mp3", 1, 20000, 1);
	wait( .2 );

	//IF SP AND PLAYER IS DEATH:LEAVE THIS FUNCTION
	if(coop_checkPlayerIsDeath()){return;}
		
	//--- call the end cinematic
	thread cinematicArm_End_Start();
}




//===================================================================================================================================================
//===================================================================================================================================================
//  BOSS ACTION FUNCTIONS
//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// bossAction_MoveRequest
// vecGoal - vector, the point in space to move to
// intAngularTolerance - float, the angle tolerance used to figure
//						 out if the boss is at the desired location
// returns - boolean, whether or not the boss is currently there
//			 TRUE means that the boss is there
// takes the passed in point, calculates it's angular position
// compares the distance and returns whether the boss is already
// there or if it has to move.  If it's there, it will stop the rig
// if it has to move, it will figure out the fastest way there
// and move him in that direction
//---------------------
float bossAction_MoveRequest( vector vecGoal, float intAngularTolerance )
{
	//--- variables
	float intAngularDistance;
	
	//--- set the Z value to 0
	vecGoal = vectorsetz( vecGoal, 0 );

	//--- get the angular distance between the passed in goal and the current position of the rig
	intAngularDistance = commonGet_AngularDistance( vecGoal, $boss_rig.getorigin() );
   	
	//--- is the angular distance within the passed in angluar tolerance zone
	if( commonGet_WithinAngularTolerance( intAngularDistance, intAngularTolerance ) == TRUE )
	{
		//--- the rig is already at the desired location, stop him
		bossAction_MoveStop();
		return( TRUE );
	}

	//--- store the goal as the boss' current goal
	vecBossPositionGoal = vecGoal;
		
	//--- evaluate which angluar direction is faster
	if( intAngularDistance >= 0 )
	{
		//--- counter clockwise
		$boss_rig_mover.rotateY( (-1 * intBossMove_Speed) );
	}
	else
	{
		//--- clockwise
		$boss_rig_mover.rotateY( intBossMove_Speed );
	}

	return( FALSE );
}


//---------------------
// bossAction_MoveStop
// stop the rig
//---------------------
void bossAction_MoveStop()
{
	$boss_rig_mover.rotateY( 0 );
}

//---------------------------------------------------------------------------------------------
//---  TAUNT FUNCTIONS
//---------------------------------------------------------------------------------------------

//---------------------
// 	bossAction_Taunt
//	fltAttack - float, the type of attack to pick a taunt for, based off of the state constants
// 	the boss randomly picks a taunt for the passed in type of attack
//---------------------
void bossAction_Taunt( float fltAttack )
{
	string strDialog;

	//--- determine the type of attack to pick a taunt for
	//---------------------------------
	//--- boost taunts
	if( fltAttack == BOSS_STATE_BOOST )
	{
		//--- pick a taunt that wasn't used last time
		fltTauntBoost_Previous = bossAction_TauntChoose( fltTauntBoost_Previous );
		
		//--- pick the appropriate line based on the choice
		if( fltTauntBoost_Previous == 0 )
		{
			strDialog = "m9l2/klingcomm_canrun.mp3";	//You cannot run, human veQ!
			
		}
		else if( fltTauntBoost_Previous == 1 )
		{
			strDialog = "m9l2/klingcomm_elude.mp3";	//You try and elude me, Starfleet k'pekt!?
		}
		else
		{
			strDialog = "m9l2/klingcomm_coming.mp3";	//I am coming for you, human!
		}
	}
	//---------------------------------
	//--- flameburst taunts
	else if( fltAttack == BOSS_STATE_FLAMEBURST )
	{
		//--- pick a taunt that wasn't used last time
		fltTauntFlameburst_Previous = bossAction_TauntChoose( fltTauntFlameburst_Previous );
		
		//--- pick the appropriate line based on the choice
		if( fltTauntFlameburst_Previous == 0 )
		{
			strDialog = "m9l2/klingcomm_taste.mp3";	//Taste fire, Federation dog!
		}
		else if( fltTauntFlameburst_Previous == 1 )
		{
			strDialog = "m9l2/klingcomm_burntarg.mp3";	//You will burn like a Targ in a pit!
		}
		else
		{
			strDialog = "m9l2/klingcomm_flame.mp3";	//Then surrender to flame, k'pekt!
		}	
	}
	//---------------------------------
	//--- scan taunts
	else if( fltAttack == BOSS_STATE_SCAN )
	{
		//--- pick a taunt that wasn't used last time
		fltTauntScan_Previous = bossAction_TauntChoose( fltTauntScan_Previous );
		
		//--- pick the appropriate line based on the choice
		if( fltTauntScan_Previous == 0 )
		{
			strDialog = "m9l2/klingcomm_scanfind.mp3";	//My scan will find you out, weak yIntagh!
		}
		else if( fltTauntScan_Previous == 1 )
		{
			strDialog = "m9l2/klingcomm_tohpah.mp3";	//Toh-pah!
		}
		else
		{
			strDialog = "m9l2/klingcomm_escape.mp3";	//You cannot escape the uD'a', human!
		}		
	}
	//---------------------------------
	//--- airlock taunts
	else if( fltAttack == BOSS_STATE_AIRLOCK )
	{
		//--- pick a taunt that wasn't used last time
		fltTauntAirlock_Previous = bossAction_TauntChoose( fltTauntAirlock_Previous );
		
		//--- pick the appropriate line based on the choice
		if( fltTauntAirlock_Previous == 0 )
		{
			strDialog = "m9l2/klingcomm_cold.mp3";	//Space is cold, Starfleet qoH!
		}
		else if( fltTauntAirlock_Previous == 1 )
		{
			strDialog = "m9l2/klingcomm_vent.mp3";	//Time to vent this piece of Bak'tagh!
		}
		else
		{
			strDialog = "m9l2/klingcomm_breathe.mp3";	//Can you breathe in a vacuum, taHqeq!?
		}			
	}
	
	bossAction_TauntSay( strDialog );
}

//---------------------
// 	bossAction_TauntChoose
//	fltPrevious - float, the previous choice used
//	RETURN - float, the new choice
// 	picks a random integer between 0 and 2, will keep picking until it picks
//	a different choice than what was passed into the function
//---------------------
float bossAction_TauntChoose( float fltPrevious )
{
	//--- set the choice variable equal to the passed in choice so it will generate the first random choice
	float intChoice;
	intChoice = fltPrevious;
	
	//--- loop until a new choice is picked
	while( intChoice == fltPrevious )
	{
		intChoice = randomInt( 3 );
	}
	
	//--- return the new choice
	return( intChoice );
}

//---------------------
// 	bossAction_TauntSay
//	strDialog - string, the passed in path to the dialog .mp3 file
// 	makes the boss say the passed in dialog file
//---------------------
void bossAction_TauntSay( string strDialog )
{
	//--- stop whatever he was saying before
	$cinematicMerc.stopdialog();
	
	//--- say the choosen line
	thread globalCoop_dialog_play($cinematicMerc,strDialog,1, 20000,1);
}


//---------------------------------------------------------------------------------------------
//---  PHASE CHANGE STATE FUNCTIONS
//---------------------------------------------------------------------------------------------

//---------------------
// bossAction_PhaseChangeState_Start
// function called to initiate a phase change
//---------------------
void bossAction_PhaseChangeState_Start()
{
	//print( "PHASE CHANGE: start\n" );
	
	//--- stop the rig
	bossAction_MoveStop();

	//--- set that the boss can attack
	bossSet_CanAttack( FALSE );

	//--- set that the player can position
	bossSet_PlayerCanPosition( FALSE );

   	//--- set that the boss can be damaged by the vent
	bossSet_VentDamageAllowed( FALSE );

	//--- set the move boss switch display, which will set all the other rig states
	arenaSwitchMoveBoss_Display_BossInControl();

	//--- give enough time for the animation to finish
	wait( PHASE_CHANGE_ANIMATION_DELAY );

	//--- turn off the rigs AI
	$boss_rig.ai_off();
	
	//--- set the new substate
	bossSet_StatePhaseChange( PHASE_CHANGE_STATE_CINEMATIC );
}


//---------------------
// bossAction_PhaseChangeState_Cinematic
// function called to start the phase change cinematic
//---------------------
void bossAction_PhaseChangeState_Cinematic()
{
	string strAssemble;
	
	//--- stage change music
	//music( "surprise" );
	
	//--- set the flag that the cinematic started
	boolPhaseCinematic_Active = TRUE;

	//--- launch the stage cinematic start function
	thread cinematicStageChange_Start();

	//--- wait until the cinematic thread is over
	while( boolPhaseCinematic_Active == TRUE )
	{
		wait( .1 );
	}

	//--- set the new substate
	bossSet_StatePhaseChange( PHASE_CHANGE_STATE_POST );	
}


//---------------------
// bossAction_PhaseChangeState_Post
// function called to wrap up the phase change cinematics
//---------------------
void bossAction_PhaseChangeState_Post()
{
	//print( "PHASE CHANGE: post\n" );
	
	//--- if the boss is entering phase 4, set the death state
	if( intBoss_CurrentPhase == 4 )
	{
        //--- set the death state to kill the rig's think threads
        bossSet_State( BOSS_STATE_DEATH );
    }
    //--- else set all the other states on the boss back to normal
    else
    {
    	//--- turn on the rigs AI
    	wait( 1.5 );
    	$boss_rig.ai_on();
    	
    	//--- set that the player can position
    	bossSet_PlayerCanPosition( FALSE );
    
       	//--- set that the boss can be damaged by the vent
    	bossSet_VentDamageAllowed( FALSE );
    
    	//--- set the move boss switch display, which will set all the other rig states
    	arenaSwitchMoveBoss_Display_BossInControl();
    
    	//--- set that the boss can attack
    	bossSet_CanAttack( TRUE );
    
    	//--- set the new substate
    	bossSet_StatePhaseChange( PHASE_CHANGE_STATE_NONE );
    	
    	//--- activate the boss
		if(cvar_bool_multiplayer){
			$boss_rig.fov(360);
			$boss_rig.aggressive(1);
		}
		else{
			$boss_rig.attack( eBossHatesMe );
		}
    }
}
	
	
//---------------------------------------------------------------------------------------------
//---  BROKEN STATE FUNCTIONS
//---------------------------------------------------------------------------------------------

//---------------------
// bossAction_BrokenState_Start
// function called to initiate the broken state
//---------------------
void bossAction_BrokenState_Start()
{
	//--- stop the rig
	bossAction_MoveStop();

	//--- set that the boss can't attack to hault his attack eval loop
	bossSet_CanAttack( FALSE );

   	//--- set that the boss can be damaged by the vent
	bossSet_VentDamageAllowed( TRUE );

	//--- launch the damage thread
	thread arenaVent_Damage();

	//--- set that the player can position
	bossSet_PlayerCanPosition( TRUE );

	//--- set the move boss switch display, which will set all the other rig states
	arenaSwitchMoveBoss_Display_CanPosition();

	//--- set the new substate
	bossSet_StateBroken( BROKEN_STATE_WAIT );
}


//---------------------
// bossAction_BrokenState_Wait
// function called while waiting for the player to position the boss
//---------------------
void bossAction_BrokenState_Wait()
{
	//--- wait until the player has pressed the switch
	if( bossGet_MoveToVent() == TRUE )
	{
    	//--- set that the player can position
    	bossSet_PlayerCanPosition( FALSE );

		//--- set the move boss switch display, which will set all the other rig states
		arenaSwitchMoveBoss_Display_MoveToVent();

		//--- set the broken substate
		bossSet_StateBroken( BROKEN_STATE_MOVE_TO_VENT );
	}
}


//---------------------
// bossAction_BrokenState_MoveToVent
// function called to move the boss to the vent
//---------------------
void bossAction_BrokenState_MoveToVent()
{
	float boolBossAtVent;

	//--- set the bosses move speed
	intBossMove_Speed = BOSS_MOVE_SPEED_TO_VENT;
	
	//--- move the boss
	boolBossAtVent = bossAction_MoveRequest( $bossVentSpot.getorigin(), BOSS_MOVE_TOLERANCE_NORMAL );
	
	//--- check if the rig is at the vent
	if( boolBossAtVent == TRUE )
	{
    	//--- set the new substate
    	bossSet_StateBroken( BROKEN_STATE_AT_VENT );
    }
}

//---------------------
// bossAction_BrokenState_AtVent
// function called when the boss is at the vent
//---------------------
void bossAction_BrokenState_AtVent()
{
	//--- set the at vent flag
	bossSet_AtVent( TRUE );
	wait( .01 );
}


//---------------------
// bossAction_BrokenState_Post
// function called when the broken state is over
//---------------------
void bossAction_BrokenState_Post()
{
	//--- stop the rig
	bossAction_MoveStop();

	//--- set that the player can position
	bossSet_PlayerCanPosition( FALSE );

   	//--- set that the boss can be damaged by the vent
	bossSet_VentDamageAllowed( FALSE );

	//--- set that the boss is not at the vent anymore
	bossSet_AtVent( FALSE );

	//--- set the move boss switch display, which will set all the other rig states
	arenaSwitchMoveBoss_Display_BossInControl();

	//--- set that the boss can attack
	bossSet_CanAttack( TRUE );

	//--- set the new substate
	bossSet_StateBroken( BROKEN_STATE_NONE );
}


//---------------------------------------------------------------------------------------------
//---  SCAN STATE FUNCTIONS
//---------------------------------------------------------------------------------------------

//---------------------
// bossAction_ScanState_Start
// function called when the scan state is to be started
//---------------------
void bossAction_ScanState_Start()
{
	//--- stop the rig
	bossAction_MoveStop();

	//--- set that the boss can't attack to hault his attack eval loop
	bossSet_CanAttack( FALSE );

	//--- tell the boss to attack the central pillar so he's lined up properly
	//$boss_rig.attack( $boss_rig_mover );
	
	//--- set the behavior package on the boss rig
	$boss_rig.setbehaviorpackage( "rigboss_startscan" );
	
	//--- set the rigs angles
	$boss_rig.angles( '0 180 0' );
	//$boss_rig.turnTowardsEntity( $ventFire );
	
	//--- boss attack warning indicator taunt
	thread bossAction_Taunt( BOSS_STATE_SCAN );

	//--- start the boss dock extending
	thread arenaBossDock_ExtendPhase1();

	//--- set the new substate
	bossSet_StateScan( SCAN_STATE_MOVE_TO_SAFETY );
}


//---------------------
// bossAction_ScanState_MoveToSafety
// function called to move the rig to safety
//---------------------
void bossAction_ScanState_MoveToSafety()
{
	float boolBossAtSafety;
	
	//--- set the bosses move speed
	intBossMove_Speed = BOSS_MOVE_SPEED_SCAN;
	
	//--- move the boss
	boolBossAtSafety = bossAction_MoveRequest( $bossScanPortSpot.getorigin(), BOSS_MOVE_TOLERANCE_SCAN );
	
	//--- check if the rig is at the vent
	if( boolBossAtSafety == TRUE )
	{
    	//--- set the new substate
    	bossSet_StateScan( SCAN_STATE_AT_SAFETY );
    }	
}


//---------------------
// bossAction_ScanState_AtSafety
// function called when the boss is at his safety spot
//---------------------
void bossAction_ScanState_AtSafety()
{
	//--- make the boss rig notsolid
	$boss_rig.notsolid();

	//--- snap the boss into position
	$boss_rig_mover.angles( '0 0 0' );

	//--- wait until the dock is extended
	while( boolBossDock_BaseExtended == FALSE )
	{
		wait( .1 );
	}
		
	//--- activate the forcefield
	arenaBossDock_ExtendPhase2();
	wait( .25 );
	
	//--- show the beam and make it hurtable
	arenaScan_ShowBeam();
	wait( 1 );
	
	//--- sweep the beam
	arenaScan_DoScan();
	wait( 1 );

	//--- hide the beam
	arenaScan_HideBeam();
	
	//--- remove the forcefield
	arenaBossDock_RetractPhase1();
	
	//--- set the scan state
	bossSet_StateScan( SCAN_STATE_POST );
}


//---------------------
// bossAction_ScanState_Post
// function called to wrap up the scan attack
//---------------------
void bossAction_ScanState_Post()
{
	//--- make the boss rig notsolid
	$boss_rig.solid();

	//--- retract the dock
	thread arenaBossDock_RetractPhase2();

	//--- set the bosses move speed
	intBossMove_Speed = BOSS_MOVE_SPEED_NORMAL;

	//--- set that the boss can't attack to hault his attack eval loop
	bossSet_CanAttack( TRUE );
	
	//--- set the behavior package on the boss rig
	$boss_rig.setbehaviorpackage ( "rigboss_endscan" );

	//--- set the new substate
	bossSet_StateScan( SCAN_STATE_NONE );
	
	//--- activate the boss
	//$boss_rig.attack( eBossHatesMe );
}


//---------------------------------------------------------------------------------------------
//---  BOOST STATE FUNCTIONS
//---------------------------------------------------------------------------------------------

//---------------------
// bossAction_BoostState_Start
// function called when the boost state is to be started
//---------------------
void bossAction_BoostState_Start()
{
	//--- stop the rig
	bossAction_MoveStop();

	//--- set that the boss can't attack to hault his attack eval loop
	bossSet_CanAttack( FALSE );
	
	//--- set the boost goal
	vecBossBoostGoal = eBossHatesMe.getorigin();
	
	//print( "BOOST START: boost goal: " + vecBossBoostGoal + "\n" );
	
	//--- set the rigs speed to boost speed
	intBossMove_Speed = BOSS_MOVE_SPEED_BOOST;

	//--- set the bosses behavior package.......THE PACKAGE!!!!!	
	$boss_rig.setbehaviorpackage ( "rigboss_startboost" );

	//--- boss attack warning indicator taunt
	thread bossAction_Taunt( BOSS_STATE_BOOST );


	//--- set the new substate
	bossSet_StateBoost( BOOST_STATE_MOVE_TO_GOAL );
}


//---------------------
// bossAction_BoostState_MoveToGoal
// function called for the boost state to move to the goal position
//---------------------
void bossAction_BoostState_MoveToGoal()
{
	//--- variables
	float boolBossAtGoal;
	
	//--- move the boss
	//print( "BOOST MOVE TO GOAL: boost goal: " + vecBossBoostGoal + "\n" );
	boolBossAtGoal = bossAction_MoveRequest( vecBossBoostGoal, BOSS_MOVE_TOLERANCE_BOOST );

	//print( "BOOST MOVE TO GOAL: boss at goal: " + boolBossAtGoal + "\n" );
	
	//--- check if the rig is at the vent
	if( boolBossAtGoal == TRUE )
	{
    	//--- set the new substate
    	bossSet_StateBoost( BOOST_STATE_AT_GOAL );
    }
}


//---------------------
// bossAction_BoostState_AtGoal
// function called for the boost state when the rig's at the goal
//---------------------
void bossAction_BoostState_AtGoal()
{
	//--- perform homing rocket attack, SET THE PACKAGE!!!!
	$boss_rig.setbehaviorpackage ( "rigboss_endboost" );
	wait( 2 );

	//--- set the new substate
	bossSet_StateBoost( BOOST_STATE_POST );
}


//---------------------
// bossAction_BoostState_Post
// function called to wrap up the boost attack
//---------------------
void bossAction_BoostState_Post()
{
	//--- set that the boss can't attack to hault his attack eval loop
	bossSet_CanAttack( TRUE );
	
	//--- set the rigs speed to boost speed
	intBossMove_Speed = BOSS_MOVE_SPEED_NORMAL;
	
	//--- set the new substate
	bossSet_StateBoost( BOOST_STATE_NONE );
}




//===================================================================================================================================================
//===================================================================================================================================================
//  BOSS AI CALLED FUNCTIONS
//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// bossAI_EnterRepairState
// tell the logic the boss has entered the repair state
//---------------------
void bossAI_EnterRepairState()
{
	//print( "ENTER REPAIR STATE\n" );
    music("surprise");

	//--- set the speed of the rig back to normal
	intBossMove_Speed = BOSS_MOVE_SPEED_NORMAL;
	
	//--- set the broken sub-state
	bossSet_StateBroken( BROKEN_STATE_START );

	//--- set the broken state on the boss
	bossSet_State( BOSS_STATE_BROKEN );

	$bossRepairModeMovementClip.solid();
}


//---------------------
// bossAI_ExitRepairState
// tell the logic the boss has exited the repair state
//---------------------
void bossAI_ExitRepairState()
{
	//print( "EXITING REPAIR STATE\n" );

	//--- set the speed of the rig back to normal
	intBossMove_Speed = BOSS_MOVE_SPEED_NORMAL;

	//--- set the broken state on the boss
	bossSet_StateBroken( BROKEN_STATE_POST );

	$bossRepairModeMovementClip.notsolid();
	
}


//---------------------
// bossAI_EnterPhase2
// tell the logic that the boss is transitioning to phase 2
//---------------------
void bossAI_EnterPhase2()
{
	//centerprint( "ENTER PHASE2: starting\n" );
	//print( "ENTER PHASE2: starting\n" );

	//--- set the phase of the boss
	intBoss_CurrentPhase = 2;

	//--- set the speed of the rig back to normal
	intBossMove_Speed = BOSS_MOVE_SPEED_NORMAL;

	//--- set the flameburst door and fire delay times
	fltFlameburst_DoorTime = FLAMEBURST_DOOR_TIME_PHASE2;
	fltFlameburst_FireDelayTime = FLAMEBURST_DOOR_FIRE_DELAY_PHASE2;

	//--- set the speed of the scan beam
	intScanBeamTime = SCAN_BEAM_TIME_PHASE2;

	//--- set the scan attack to active
	boolBossAttack_ScanAvailable = TRUE;
	
	//--- set the Phase change substate
	bossSet_StatePhaseChange( PHASE_CHANGE_STATE_START );

	//--- set the Phase change state on the boss
	bossSet_State( BOSS_STATE_PHASE_CHANGE );
}


//---------------------
// bossAI_EnterPhase3
// tell the logic that the boss is transitioning to phase 3
//---------------------
void bossAI_EnterPhase3()
{
	//centerprint( "ENTER PHASE3: starting\n" );
	//print( "ENTER PHASE3: starting\n" );

	//--- set the phase of the boss
	intBoss_CurrentPhase = 3;

	//--- set the speed of the rig back to normal
	intBossMove_Speed = BOSS_MOVE_SPEED_NORMAL;

	//--- set the flameburst door and fire delay times
	fltFlameburst_DoorTime = FLAMEBURST_DOOR_TIME_PHASE3;
	fltFlameburst_FireDelayTime = FLAMEBURST_DOOR_FIRE_DELAY_PHASE3;

	//--- set the speed of the scan beam
	intScanBeamTime = SCAN_BEAM_TIME_PHASE3;

	//--- set the airlock attack to active
	//boolBossAttack_AirlockAvailable = TRUE;
	boolBossAttack_AirlockAvailable = FALSE;

	//--- set the flameburst to in-active
	boolBossAttack_FlameburstAvailable = FALSE;

	//--- set the Phase change substate
	bossSet_StatePhaseChange( PHASE_CHANGE_STATE_START );

	//--- set the Phase change state on the boss
	bossSet_State( BOSS_STATE_PHASE_CHANGE );
}


//---------------------
// bossAI_EnterPhase4
// tell the logic that the boss is transitioning to phase 4
//---------------------
void bossAI_EnterPhase4()
{
	//centerprint( "ENTER PHASE4: starting\n" );
	//print( "ENTER PHASE4: starting\n" );

	//--- set the speed of the rig back to normal
	intBossMove_Speed = BOSS_MOVE_SPEED_NORMAL;

	//--- set the phase of the boss
	intBoss_CurrentPhase = 4;

	//--- set the Phase change substate
	bossSet_StatePhaseChange( PHASE_CHANGE_STATE_START );

	//--- set the Phase change state on the boss
	bossSet_State( BOSS_STATE_PHASE_CHANGE );
}




//===================================================================================================================================================
//===================================================================================================================================================
//  BOSS SETTER FUNCTIONS
//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// bossSet_Updating
// sets the updating flag of the boss state to true
//---------------------
void bossSet_Updating()
{
	boolBossState_IsUpdating = TRUE;
}


//---------------------
// bossSet_UpdatingDone
// sets the updating flag of the boss state to false
//---------------------
void bossSet_UpdatingDone()
{
	boolBossState_IsUpdating = FALSE;
}


//---------------------
// bossSet_State
// fltStateToSet - float, the state to set
// sets the state of the boss
//---------------------
void bossSet_State( float fltStateToSet )
{
	//--- if the boss state is currently updating, wait
	bossGet_WhileUpdating();
	
	//--- set the updating flag
	bossSet_Updating();
	
	//print( "SET STATE: State to set: " + fltStateToSet + "\n" );
	//print( "SET STATE: Current state: " + enumBossState_Current + "\n" );
	
	//--- compare the requested state with his current, if higher priority or a reset command then set it
	if( fltStateToSet < enumBossState_Current || fltStateToSet == BOSS_STATE_RESET )
	{
		//--- set the state to the passed in state
		enumBossState_Current = fltStateToSet;
	}
	
	//--- relinquish the updating
	bossSet_UpdatingDone();
}


//---------------------
// bossSet_StatePhaseChange
// fltStateToSet - float, the sub state to set
// sets the Phase change sub state
//---------------------
void bossSet_StatePhaseChange( float fltStateToSet )
{
	enumBossState_PhaseChange = fltStateToSet;
}


//---------------------
// bossSet_StateBroken
// fltStateToSet - float, the sub state to set
// sets the broken sub state
//---------------------
void bossSet_StateBroken( float fltStateToSet )
{
	enumBossState_Broken = fltStateToSet;
}


//---------------------
// bossSet_StateScan
// fltStateToSet - float, the sub state to set
// sets the scan sub state
//---------------------
void bossSet_StateScan( float fltStateToSet )
{
	enumBossState_Scan = fltStateToSet;
}


//---------------------
// bossSet_StateBoost
// fltStateToSet - float, the sub state to set
// sets the boost sub state
//---------------------
void bossSet_StateBoost( float fltStateToSet )
{
	enumBossState_Boost = fltStateToSet;
}


//---------------------
// bossSet_VentDamageAllowed
// sets whether the vent can damage the boss
//---------------------
void bossSet_VentDamageAllowed( float boolStateToSet )
{
	boolBossDamage_VentAllowed = boolStateToSet;
}


//---------------------
// bossSet_PlayerCanPosition
// sets that whether the player can position the boss
//---------------------
void bossSet_PlayerCanPosition( float boolStateToSet )
{
	//--- set the flag that the player can position
	boolBossMove_PlayerCanPosition = boolStateToSet;
}


//---------------------
// bossSet_CanAttack
// sets whether or not the boss can attack
//---------------------
void bossSet_CanAttack( float boolStateToSet )
{
	boolBossAttack_Available = boolStateToSet;
}


//---------------------
// bossSet_MoveToVent
// sets whether or not to move the boss to the vent
//---------------------
void bossSet_MoveToVent( float boolStateToSet )
{
	boolBossMove_GoToVent = boolStateToSet;
}


//---------------------
// bossSet_AtVent
// sets whether or not the boss is at the vent
//---------------------
void bossSet_AtVent( float boolStateToSet )
{
	boolBossMove_AtVent = boolStateToSet;
}




//===================================================================================================================================================
//===================================================================================================================================================
//  BOSS GETTER FUNCTIONS
//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// bossGet_WhileUpdating
// while the boss is updating, wait
//---------------------
void bossGet_WhileUpdating()
{
	//--- while the boss state is updating, wait
	while( boolBossState_IsUpdating == TRUE )
	{
		//print( "UPDATING: BOSS IS UPDATING\n" );
		wait( .1 );
	}
}


//---------------------
// bossGet_State
// returns - float, the state of the boss
// checks and returns the current state of the boss
//---------------------
float bossGet_State()
{
	return( enumBossState_Current );
}


//---------------------
// bossGet_StatePhaseChange
// returns - float, the Phase change sub state of the boss
// checks and returns the current Phase change sub state of the boss
//---------------------
float bossGet_StatePhaseChange()
{
	return( enumBossState_PhaseChange );
}


//---------------------
// bossGet_StateBroken
// returns - float, the broken sub state of the boss
// checks and returns the current broken sub state of the boss
//---------------------
float bossGet_StateBroken()
{
	return( enumBossState_Broken );
}


//---------------------
// bossGet_StateScan
// returns - float, the scan sub state of the boss
// checks and returns the current scan sub state of the boss
//---------------------
float bossGet_StateScan()
{
	return( enumBossState_Scan );
}


//---------------------
// bossGet_StateBoost
// returns - float, the boost sub state of the boss
// checks and returns the current boost sub state of the boss
//---------------------
float bossGet_StateBoost()
{
	return( enumBossState_Boost );
}


//---------------------
// bossGet_VentDamageAllowed
// gets the value of if the vent can damage the boss
//---------------------
float bossGet_VentDamageAllowed()
{
	return( boolBossDamage_VentAllowed );
}


//---------------------
// bossGet_PlayerCanPosition
// gets the value of if the player can position the boss
//---------------------
float bossGet_PlayerCanPosition()
{
	return( boolBossMove_PlayerCanPosition );
}


//---------------------
// bossGet_CanAttack
// gets the value of if the boss can attack
//---------------------
float bossGet_CanAttack()
{
	return( boolBossAttack_Available );
}


//---------------------
// bossGet_MoveToVent
// gets the value of whether or not to move the boss to the vent
//---------------------
float bossGet_MoveToVent()
{
	return( boolBossMove_GoToVent );
}


//---------------------
// bossGet_AtVent
// gets the value of whether or not the boss is at the vent
//---------------------
float bossGet_AtVent()
{
	return( boolBossMove_AtVent );
}




//===================================================================================================================================================
//===================================================================================================================================================
//  ARENA FUNCTIONS
//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// arenaSwitchMoveBoss_Execute
// the player hit the switch to move the boss to the vent
//---------------------
void arenaSwitchMoveBoss_Execute()
{
	$switchMoveBoss_Trigger.nouse();
	
	//--- if the boss is in a player moveable state then set the flag to move the boss
	if( bossGet_PlayerCanPosition() == TRUE )
	{
		//--- set the variable to move to vent
		bossSet_MoveToVent( TRUE );
		
		//--- play acknowledge sound
		$switchMoveBoss_Trigger.playsound( "sound/ships/klingon/kling_beepalarm.wav", 1, 2, 64 );
	}
	else
	{
		//--- play an error beep
		$switchMoveBoss_Trigger.playsound( "sound/ships/klingon/kling_beep1.wav", 1, 2, 64 );
	}
	
	wait( 1 );
	thread globalCommon_OnUse( $switchMoveBoss_Trigger, "arenaSwitchMoveBoss_Execute" );
}


//---------------------
// arenaSwitchMoveBoss_Display_BossInControl
// changes the move boss switch display to boss in control
//---------------------
void arenaSwitchMoveBoss_Display_BossInControl()
{
	//--- show and hide the proper displays
	$switchMoveBoss_PlayerCanUse.hide();
	$switchMoveBoss_BossInControl.show();
	$switchMoveBoss_MovingToVent.hide();

	//--- hide the light indicator
	$switchMoveBoss_IndicatorLight.hide();
	$world.light_lightstyle( "switchMoveBoss_IndicatorLight_Light", "a", 0 );

	//--- hide the light indicator
	$switchActivateVent_IndicatorLight.hide();
	$world.light_lightstyle( "switchActivateVent_IndicatorLight_Light", "a", 0 );
	
	//--- set the variable to move to vent
	bossSet_MoveToVent( FALSE );
}


//---------------------
// arenaSwitchMoveBoss_Display_CanPosition
// changes the move boss switch display to can position
//---------------------
void arenaSwitchMoveBoss_Display_CanPosition()
{
	//--- show and hide the proper displays
	$switchMoveBoss_PlayerCanUse.show();
	$switchMoveBoss_BossInControl.hide();
	$switchMoveBoss_MovingToVent.hide();
	
	//--- show the light indicator
	$switchMoveBoss_IndicatorLight.show();
	$world.light_lightstyle( "switchMoveBoss_IndicatorLight_Light", "zzzaaaaaaaaaaaaaaa", 0 );
}


//---------------------
// arenaSwitchMoveBoss_Display_MoveToVent
// changes the move boss switch display to moving to vent
//---------------------
void arenaSwitchMoveBoss_Display_MoveToVent()
{
	//--- show and hide the proper displays
	$switchMoveBoss_PlayerCanUse.hide();
	$switchMoveBoss_BossInControl.hide();
	$switchMoveBoss_MovingToVent.show();

	//--- hide the light indicator
	$switchMoveBoss_IndicatorLight.hide();
	$world.light_lightstyle( "switchMoveBoss_IndicatorLight_Light", "a", 0 );

	//--- show the vent light indicator
	$switchActivateVent_IndicatorLight.show();
	$world.light_lightstyle( "switchActivateVent_IndicatorLight_Light", "zzzaaaaaaaaaaaaaaa", 0 );

	//--- set the variable to move to vent
	bossSet_MoveToVent( FALSE );
}

//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// arenaSwitchFireVent_Execute
// activates the vent blast to damage the rig
//---------------------
void arenaSwitchFireVent_Execute()
{
	$switchActivateVent_Trigger.nouse();
	
	//--- if the boss is in a player moveable state then set the flag to move the boss
	if( boolVent_Available == TRUE )
	{
		//--- play acknowledge sound
		$switchActivateVent_Trigger.playsound( "sound/ships/klingon/kling_beepalarm.wav", 1, 2, 64 );
		
		//--- blast the vent
		thread arenaVent_Fire();
	}
	else
	{
		//--- play an error beep
		$switchActivateVent_Trigger.playsound( "sound/ships/klingon/kling_beep1.wav", 1, 2, 64 );
	}
	
	wait( 1 );
	thread globalCommon_OnUse( $switchActivateVent_Trigger, "arenaSwitchFireVent_Execute" );
}


//---------------------
// arenaSwitchFireVent_Display_Ready
// changes the vent switch display to ready
//---------------------
void arenaSwitchFireVent_Display_Ready()
{
	$switchActivateVent_Usable.show();
	$switchActivateVent_InUse.hide();
	$switchActivateVent_Charging.hide();

	//--- hide the light indicator
	$switchActivateVent_IndicatorLight.hide();
	$world.light_lightstyle( "switchActivateVent_IndicatorLight_Light", "a", 0 );
}


//---------------------
// arenaSwitchFireVent_Display_Firing
// changes the vent switch display to firing
//---------------------
void arenaSwitchFireVent_Display_Firing()
{
	$switchActivateVent_Usable.hide();
	$switchActivateVent_InUse.show();
	$switchActivateVent_Charging.hide();

	//--- hide the light indicator
	$switchActivateVent_IndicatorLight.hide();
	$world.light_lightstyle( "switchActivateVent_IndicatorLight_Light", "a", 0 );
}


//---------------------
// arenaSwitchFireVent_Display_Charging
// changes the vent switch display to charging
//---------------------
void arenaSwitchFireVent_Display_Charging()
{
	$switchActivateVent_Usable.hide();
	$switchActivateVent_InUse.hide();
	$switchActivateVent_Charging.show();

	//--- hide the light indicator
	$switchActivateVent_IndicatorLight.hide();
	$world.light_lightstyle( "switchActivateVent_IndicatorLight_Light", "a", 0 );
}


//---------------------
// arenaVent_Fire
// logic that controls the actual blasting of the vent
//---------------------
void arenaVent_Fire()
{
	//--- set the flag
	boolVent_Available = FALSE;

	//--- make the trigger hurt for the player active
	$triggerVentFire_Damage.triggerable();

	//--- change out the panels
	arenaSwitchFireVent_Display_Firing();

	//--- activate the fire
	$ventFire.anim( "burn" );
	
	//--- mark the vent as active
	boolVent_Active = TRUE;

	//--- wait for the amount of time it's supposed to stay active
	wait( VENT_ACTIVE_TIME );
	
	//--- deactivate the fire
	$ventFire.anim( "idle" );
		
	//--- mark the vent as inactive
	boolVent_Active = FALSE;

	//--- make the trigger hurt for the player inactive
	$triggerVentFire_Damage.nottriggerable();

	//--- change out the panels
	arenaSwitchFireVent_Display_Charging();
	
	//--- wait the charge up time
	wait( VENT_CHARGE_TIME );
	
	//--- change out the panels
	arenaSwitchFireVent_Display_Ready();
	
	//--- set the flag
	boolVent_Available = TRUE;
}


//---------------------
// arenaVent_Damage
// damage the rig with the flame burst
//---------------------
void arenaVent_Damage()
{
	float intAngularDistance;
	
	while( 	bossGet_VentDamageAllowed() == TRUE )
	{
		//--- get the angular distance between the boss rig and the vent spot
		intAngularDistance = commonGet_AngularDistance( $boss_rig.getOrigin(), $bossVentSpot.getOrigin() );

    	//--- check to see if the flame is active, and if the boss is in a position to be damaged by it
    	//if( boolVent_Active == TRUE && bossGet_AtVent() == TRUE )
    	if( boolVent_Active == TRUE && (commonGet_WithinAngularTolerance( intAngularDistance, VENT_DISTANCE_TOLERANCE ) == TRUE) )
    	{
    		//centerprint( "DAMAGE RIG MASSIVELY" );
    		//print( "DAMAGE RIG MASSIVELY\n" );
    		//$boss_rig.setdamage( "high" );
    		$boss_rig.hurt( VENT_DAMAGE, VENT_DAMAGE_TYPE );
    		bossSet_VentDamageAllowed( FALSE );
    	}
    	else
    	{
    		//print( "RIG IS NOT ALLOWED TO BE DAMAGED\n" );
    		//print( "VENT DAMAGE: boolVent_Active: " + boolVent_Active + " : VentDamageAllowed: " + bossGet_VentDamageAllowed() + "\n" );
    		//print( "VENT DAMAGE TRIGGER: vent is not active\n" );
    		wait( .2 );
    	}
    }
}

//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// arenaScan_Damage
// damage function for anything that touches the Scan beam
//---------------------
void arenaScan_Damage()
{
	float intAngularDistance;
	
	//--- cycle while the beam is active is active to see if the beam touches the player
	while( boolScan_Active == TRUE )
	{
		//--- get the angular distance between the Scan beam and the player
		intAngularDistance = commonGet_AngularDistance( eBossHatesMe.getorigin(), $scannerScan_PositionMarker.getorigin() );

		//--- check if the beam is on top of the player by comparing their angles
		//--- if the beams angle falls within the desired tolerance range, then it's touching the player
    	if( commonGet_WithinAngularTolerance( intAngularDistance, SCAN_BEAM_DAMAGE_TOLERANCE ) == TRUE )
    	{
    		//print( "SCAN DAMAGE: touched player\n" );
    		
    		//--- damage the player
    		eBossHatesMe.hurt( SCAN_BEAM_DAMAGE, SCAN_BEAM_DAMAGE_TYPE );
    	}

    	wait( .05 );
    }
}


//---------------------
// arenaScan_ShowBeam
// show the Scan beam
//---------------------
void arenaScan_ShowBeam()
{
	$scannerScan_Beam.show();
	$scannerScan_Beam.playsound ( "sound/ships/klingon/kling_scanstart.wav", 2, 1, 1000 );
	$scannerScan_Beam.loopsound ( "sound/ships/klingon/kling_scan.wav", 3, 300 );

	//$scannerScan_Beam.solid();
	
	//--- set the flag that the scan is active
	boolScan_Active = TRUE;
	
	//--- activate the damage thread for the beam
	thread arenaScan_Damage();
}


//---------------------
// arenaScan_HideBeam
// hide the Scan beam
//---------------------
void arenaScan_HideBeam()
{
	$scannerScan_Beam.hide();
	//$scannerScan_Beam.notsolid();
	$scannerScan_Beam.playsound ( "sound/ships/klingon/kling_scanstop.wav", 2, 1, 1000 );
	$scannerScan_Beam.stoploopsound();
	//--- set the flag that the scan is not active
	boolScan_Active = FALSE;
}


//---------------------
// arenaScan_DoScan
// perform the scan
//---------------------
void arenaScan_DoScan()
{
	//--- variables
	float intAngularDistance;
	
	//--- set the move time on the beam
	$scannerScan_Base.time( intScanBeamTime );
	
	//--- get the angular distance between the Scan beam and the player
	intAngularDistance = commonGet_AngularDistance( eBossHatesMe.getorigin(), $scannerScan_PositionMarker.getorigin() );
   	
	//--- evaluate which angluar direction is closer to the player
	if( intAngularDistance >= 0 )
	{
		//--- counter clockwise
		$scannerScan_Base.rotateYdown( 360 );
	}
	else
	{
		//--- clockwise
		$scannerScan_Base.rotateYup( 360 );
	}
	
	waitFor( $scannerScan_Base );
}

//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// arenaAirlock_PickAirlock
// pick which airlock to open based on which quad the player's in
//---------------------
float arenaAirlock_PickAirlock()
{
	vector vecPlayerPosition;
	vector vecCenter;
	
	float boolXSide;		//true means he's on the west half
	float boolYSide;		//true means he's on the north half
	
	vecPlayerPosition = eBossHatesMe.getorigin();
	vecCenter = '1152 1152 708';

	//--- first check the x axis
	if( vecPlayerPosition_x < vecCenter_x )
	{
		//--- the player's on the west half
		boolXSide = TRUE;
	}
	else
	{
		//--- the player's on the east half
		boolXSide = FALSE;
	}
	
	//--- check the y axis
	if( vecPlayerPosition_y > vecCenter_y )
	{
		//--- the player's on the north half
		boolYSide = TRUE;
	}
	else
	{
		//--- the player's on the south half
		boolYSide = FALSE;
	}
	
	//--- return which quad the player's in
	if( boolXSide == TRUE && boolYSide == TRUE )
	{
		//--- he's in the north west quadrant
		//print( "AIRLOCK PICK: choosen airlock 1\n" );
		return( 1 );
	}
	else if( boolXSide == TRUE && boolYSide == FALSE )
	{
		//--- he's in the south west quadrant
		//print( "AIRLOCK PICK: choosen airlock 4\n" );
		return( 4 );
	}
	else if( boolXSide == FALSE && boolYSide == TRUE )
	{
		//--- he's in the north east quadrant
		//print( "AIRLOCK PICK: choosen airlock 2\n" );
		return( 2 );
	}
	else if( boolXSide == FALSE && boolYSide == FALSE )
	{
		//--- he's in the south east quadrant
		//print( "AIRLOCK PICK: choosen airlock 3\n" );
		return( 3 );
	}
}



//---------------------
// arenaAirlock_OpenAirlock
// intAirlock - float, the airlock number to open
// opens the passed in airlock
//---------------------
void arenaAirlock_OpenAirlock( float intAirlock )
{
	entity entAirlock_DoorA, entAirlock_DoorB;
	entity entAirlock_RimLights_On, entAirlock_RimLights_Off;
	entity entAirlock_AlertBeacon1_Base, entAirlock_AlertBeacon1_LightCone;
	entity entAirlock_AlertBeacon2_Base, entAirlock_AlertBeacon2_LightCone;
	
	string strAirlock_DoorA_OpenDirection, strAirlock_DoorB_OpenDirection;
	string strAirlock_RimLights_Normal, strAirlock_RimLights_Red;
	
	//--- get the light entities
	entAirlock_RimLights_On = getEntity( ("doorAirlock" + intAirlock + "_RimLights_On") );
	entAirlock_RimLights_Off = getEntity( ("doorAirlock" + intAirlock + "_RimLights_Off") );
	
	//--- get the alert beacons
	entAirlock_AlertBeacon1_Base = getEntity( ("doorAirlock" + intAirlock + "_AlertBeacon1_Base") );
	entAirlock_AlertBeacon2_Base = getEntity( ("doorAirlock" + intAirlock + "_AlertBeacon2_Base") );
	entAirlock_AlertBeacon1_LightCone = getEntity( ("doorAirlock" + intAirlock + "_AlertBeacon1_LightCone") );
	entAirlock_AlertBeacon2_LightCone = getEntity( ("doorAirlock" + intAirlock + "_AlertBeacon2_LightCone") );
	
	//--- assemble the light group name strings
	strAirlock_RimLights_Normal = "doorAirlock" + intAirlock + "_RimLights_LightNormal";
	strAirlock_RimLights_Red = "doorAirlock" + intAirlock + "_RimLights_LightRed";

	//--- activate the airlock attack warning indicators
	//--- turn off the normal lights and turn on the flashing red lights
	entAirlock_RimLights_On.show();
	entAirlock_RimLights_Off.hide();
	
	$world.light_lightstyle( strAirlock_RimLights_Normal, "a", 0 );
	$world.light_lightstyle( strAirlock_RimLights_Red, "zzzzzzzzzzzzzzzzzzzzaaaaaaaaaaaaaaaaaaaa", 0 );
	
	//--- activate the warning beacons
	thread globalAccelMove_RelativeY( entAirlock_AlertBeacon1_Base, 24, 1, "rampup", "" );
	globalAccelMove_RelativeY( entAirlock_AlertBeacon2_Base, 24, 1, "rampup", "" );
	wait( .25 );

	entAirlock_AlertBeacon1_LightCone.show();
	entAirlock_AlertBeacon2_LightCone.show();
	
	//--- rotate the beacons based on the stored axis value in uservar1
	if( entAirlock_AlertBeacon1_LightCone.getStringVar( "uservar1" ) == "x" )
	{
		entAirlock_AlertBeacon1_LightCone.rotateX( 360 );
	}
	else
	{
		entAirlock_AlertBeacon1_LightCone.rotateZ( 360 );
	}

	if( entAirlock_AlertBeacon2_LightCone.getStringVar( "uservar1" ) == "x" )
	{
		entAirlock_AlertBeacon2_LightCone.rotateX( 360 );
	}
	else
	{
		entAirlock_AlertBeacon2_LightCone.rotateZ( 360 );
	}

	wait( 1.5 );

	//--- capture the A door
	entAirlock_DoorA = arenaAirlock_GetADoor( intAirlock );

	//--- capture the B door
	entAirlock_DoorB = arenaAirlock_GetBDoor( intAirlock );
	
	//--- open the doors with acceleration
	thread globalAccelMove_RelativeY( entAirlock_DoorA, 1024, AIRLOCK_DOOR_TIME, "rampupdown", "" );
	globalAccelMove_RelativeY( entAirlock_DoorB, 1024, AIRLOCK_DOOR_TIME, "rampupdown", "" );

	//--- set the red lights to permanent on	
	$world.light_lightstyle( strAirlock_RimLights_Red , "zzzzzzzzzzzzzzzzzzzzzzzzzy" , 0 );
}


//---------------------
// arenaAirlock_GetADoor
// intAirlock - float, the airlock door to get
// returns an entity reference to the A door of the passed airlock
//---------------------
entity arenaAirlock_GetADoor( float intAirlock )
{
	string strAssemble;
	
	strAssemble = "doorAirlock" + intAirlock + "_A";
	//print( "AIRLOCK DOOR A TARGETNAME ASSEMBLE: " + strAssemble + "\n" );
	
	return( getentity( strAssemble ) );
}


//---------------------
// arenaAirlock_GetBDoor
// intAirlock - float, the airlock door to get
// returns an entity reference to the B door of the passed airlock
//---------------------
entity arenaAirlock_GetBDoor( float intAirlock )
{
	string strAssemble;
	
	strAssemble = "doorAirlock" + intAirlock + "_B";
	//print( "AIRLOCK DOOR B TARGETNAME ASSEMBLE: " + strAssemble + "\n" );
	
	return( getentity( strAssemble ) );
}

//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// arenaFlameburst_Activate
// do a flameburst attack
//---------------------
void arenaFlameburst_Activate()
{
return;//why is here return chriss ?
	//--- let the scan know the flameburst is starting
	g_boolFlameBurstActive = TRUE;
	
	//--- boss attack warning indicator
	globalAccelMove( $doorFlameburst_WarningBeacon_Door, '0 0 -8', .75, "rampup", "" );
	globalAccelMove_RelativeY( $doorFlameburst_WarningBeacon, 8, .75, "rampup", "" );
	wait( .25 );
	
	$world.light_lightstyle( "doorFlameburst_WarningBeacon_LightRed", "zzzzzzzzzzzzzzzzzzzzaaaaaaaaaaaaaaaaaaaa", 0 );

	//--- open the doors and wait for the specified firedelay time
	arenaFlameburst_OpenDoors();
	
	//--- show the flame jets
	$ventFlameburst.show();
	$ventFlameburst.playsound ( "sound/ships/klingon/kling_flamejet.wav", 10, 1, 500 );
	wait( fltFlameburst_FireDelayTime );

	//--- activate the flame jets and the damage checking function
	thread arenaFlameburst_DoDamage();
	arenaFlameburst_Fire();
	wait( 1 );
	
	//--- hide the flamejets
	$ventFlameburst.hide();
	$ventFlameburst.playsound ( "sound/ships/klingon/kling_flamejetstop.wav", 10, 1, 500 );	

	//--- close the doors
	thread arenaFlameburst_CloseDoors();
	
	$world.light_lightstyle( "doorFlameburst_WarningBeacon_LightRed", "a", 0 );
	wait( .25 );
	
	globalAccelMove_RelativeY( $doorFlameburst_WarningBeacon, -8, .75, "rampup", "" );
	globalAccelMove( $doorFlameburst_WarningBeacon_Door, '0 0 8', .75, "rampup", "" );
	wait( 3 );

	//--- let the scan know the flameburst is finished
	g_boolFlameBurstActive = FALSE;
}


//---------------------
// arenaFlameburst_OpenDoors
// open the flameburst doors
//---------------------
void arenaFlameburst_OpenDoors()
{
	//--- set the door times
	$doorFlameburst_North.time( fltFlameburst_DoorTime );
	$doorFlameburst_NorthEast.time( fltFlameburst_DoorTime );
	$doorFlameburst_NorthWest.time( fltFlameburst_DoorTime );
	$doorFlameburst_East.time( fltFlameburst_DoorTime );
	$doorFlameburst_West.time( fltFlameburst_DoorTime );
	$doorFlameburst_South.time( fltFlameburst_DoorTime );
	$doorFlameburst_SouthEast.time( fltFlameburst_DoorTime );
	$doorFlameburst_SouthWest.time( fltFlameburst_DoorTime );
	
	//--- tell the doors to move
	$doorFlameburst_North.playsound ( "sound/doors/drull_smldoor_01.wav", 4, 1, 500 );
	$doorFlameburst_North.moveNorth( 144 );
	$doorFlameburst_NorthEast.moveSouth( 144 );
	$doorFlameburst_NorthEast.moveWest( 144 );
	$doorFlameburst_NorthWest.moveSouth( 144 );
	$doorFlameburst_NorthWest.moveEast( 144 );
	$doorFlameburst_East.moveEast( 144 );
	$doorFlameburst_West.moveWest( 144 );
	$doorFlameburst_South.playsound ( "sound/doors/drull_smldoor_01.wav", 3, 1, 500 );
	$doorFlameburst_South.moveSouth( 144 );
	$doorFlameburst_SouthEast.moveNorth( 144 );
	$doorFlameburst_SouthEast.moveWest( 144 );
	$doorFlameburst_SouthWest.moveNorth( 144 );
	$doorFlameburst_SouthWest.moveEast( 144 );
	waitFor( $doorFlameburst_SouthWest );
	$doorFlameburst_North.playsound ( "sound/doors/drull_smldoor_stop_01.wav", 4, 1, 500 );
	$doorFlameburst_North.playsound ( "sound/doors/drull_smldoor_stop_01.wav", 3, 1, 500 );

}


//---------------------
// arenaFlameburst_OpenDoors
// burst the flame jets....roast some weenies
//---------------------
void arenaFlameburst_Fire()
{
	float i;

	//--- turn on the vents
	$ventFlameburst.anim( "burn" );
	
	//--- cycle the wait time
	for( i = 0 ; i <= FLAMEBURST_FIRE_DURATION ; i++ )
	{
		//--- if in cinematic, end the attack
		if( boolPhaseCinematic_Active == FALSE )
		{
			wait( 1 );
		}
		else
		{
			i = FLAMEBURST_FIRE_DURATION;
		}
	}
	
	//--- turn off the vents
	$ventFlameburst.anim( "idle" );
}


//---------------------
// arenaFlameburst_DoDamage
// check if the player's in the radius of the fire
// if he is, damage him
//---------------------
void arenaFlameburst_DoDamage()
{
	float i;
	float fltDistance;
	
	for( i = 0 ; i <= FLAMEBURST_FIRE_DURATION ; i += FLAMEBURST_FIRE_DAMAGE_INTERVAL )
	{
		//--- if in cinematic, don't damage the player
		if( boolPhaseCinematic_Active == FALSE )
		{
    		//--- get the distance between them
    		fltDistance = globalMath_GetXYDistance( eBossHatesMe.getorigin(), '1152 1152 708' );
    		
    		//print( "FLAMEBURST DAMAGE: distance: " + fltDistance + "\n" );
    		
    		//--- check if the distance to see if he's in or near the flames
    		if( fltDistance < FLAMEBURST_FIRE_DAMAGE_RADIUS )
    		{
    			//print( "FLAMEBURST DAMAGE: damaging the player\n" );
    			
    			//--- damage the player
    			eBossHatesMe.hurt( FLAMEBURST_FIRE_DAMAGE, FLAMEBURST_FIRE_DAMAGE_TYPE );
    		}
    	}
		
		wait( FLAMEBURST_FIRE_DAMAGE_INTERVAL );
	}
}


//---------------------
// arenaFlameburst_CloseDoors
// close the doors
//---------------------
void arenaFlameburst_CloseDoors()
{	
	//--- tell the doors to move
	$doorFlameburst_North.playsound ( "sound/doors/drull_smldoor_01.wav", 4, 1, 500 );
	$doorFlameburst_North.moveSouth( 144 );
	$doorFlameburst_NorthEast.moveNorth( 144 );
	$doorFlameburst_NorthEast.moveEast( 144 );
	$doorFlameburst_NorthWest.moveNorth( 144 );
	$doorFlameburst_NorthWest.moveWest( 144 );
	$doorFlameburst_East.moveWest( 144 );
	$doorFlameburst_West.moveEast( 144 );
	$doorFlameburst_South.playsound ( "sound/doors/drull_smldoor_01.wav", 3, 1, 500 );
	$doorFlameburst_South.moveNorth( 144 );
	$doorFlameburst_SouthEast.moveSouth( 144 );
	$doorFlameburst_SouthEast.moveEast( 144 );
	$doorFlameburst_SouthWest.moveSouth( 144 );
	$doorFlameburst_SouthWest.moveWest( 144 );
	waitFor( $doorFlameburst_SouthWest );
	$doorFlameburst_North.playsound ( "sound/doors/drull_smldoor_stop_01.wav", 4, 1, 500 );
	$doorFlameburst_North.playsound ( "sound/doors/drull_smldoor_stop_01.wav", 3, 1, 500 );
}

//===================================================================================================================================================
//===================================================================================================================================================

/*
float BOSS_DOCK_SCANNER_DISTANCE = 30;
float BOSS_DOCK_ARMLOCK_DISTANCE = 8;
float BOSS_DOCK_BASE_DISTANCE = 50;
float BOSS_DOCK_ARM_DISTANCE = 144; 112
float BOSS_DOCK_WALKWAY_DISTANCE = 80;

	$bossDock_RightScanner_SubBase3.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner_SubBase2.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner_SubBase1.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner_Base2.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner_Base1.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_RightScanner.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_SubBase3.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_SubBase2.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_SubBase1.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_Base2.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner_Base1.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_LeftScanner.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_Walkway.time( BOSS_DOCK_WALKWAY_TIME );
	$bossDock_ArmLock_Top.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_ArmLock_Bottom.time( BOSS_DOCK_SCANNER_TIME );
	$bossDock_Arm.time( BOSS_DOCK_ARM_TIME );
	$bossDock_Base.time( BOSS_DOCK_BASE_TIME );
*/	
//---------------------
// arenaBossDock_CinematicRetract
// retract the boss dock for the opening cinematic
//---------------------
void arenaBossDock_CinematicRetract()
{
	if( boolBossDock_CinematicRetract == TRUE )
	{
		return;
	}
	
	boolBossDock_CinematicRetract = TRUE;

	//--- retract the walkway
	thread globalAccelMoveX( $bossDock_Walkway, BOSS_DOCK_WALKWAY_DISTANCE , BOSS_DOCK_WALKWAY_TIME, "rampupdown", "" );
	wait( .5 );
	
	//--- release the arm locks
	thread globalAccelMoveZ( $bossDock_ArmLock_Top, BOSS_DOCK_ARMLOCK_DISTANCE, BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	globalAccelMoveZ( $bossDock_ArmLock_Bottom, (-1 * BOSS_DOCK_ARMLOCK_DISTANCE), BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	wait( .3 );
	
	//--- move the base and arm out
	thread globalAccelMoveX( $bossDock_Arm, 112, BOSS_DOCK_ARM_TIME, "rampupdown", "" );
	thread globalAccelMoveX( $bossDock_Base, BOSS_DOCK_BASE_DISTANCE , BOSS_DOCK_BASE_TIME, "rampupdown", "" );
	wait( 1 );
	
	//--- rotate the scanners
	thread globalAccelMove_RotateY( $bossDock_RightScanner_Base1, -70, 1.25, "rampup", "" );
	thread globalAccelMove_RotateY( $bossDock_LeftScanner_Base1, 70, 1.25, "rampup", "" );
	wait( 4.7 );
	
	//--- lock the arm locks
	thread globalAccelMoveZ( $bossDock_ArmLock_Top, (-1 * BOSS_DOCK_ARMLOCK_DISTANCE), BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	globalAccelMoveZ( $bossDock_ArmLock_Bottom, BOSS_DOCK_ARMLOCK_DISTANCE, BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
}


//---------------------
// arenaBossDock_ExtendPhase1
// extend the arm out waiting for the rig to get into scan position
//---------------------
void arenaBossDock_ExtendPhase1()
{
	//--- set the flag
	boolBossDock_BaseExtended = FALSE;
	
	//--- release the arm locks
	thread globalAccelMoveZ( $bossDock_ArmLock_Top, BOSS_DOCK_ARMLOCK_DISTANCE, BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	globalAccelMoveZ( $bossDock_ArmLock_Bottom, (-1 * BOSS_DOCK_ARMLOCK_DISTANCE), BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	wait( .3 );

        //**** ZAK ****
	$bossDock_Arm.playsound ( "sound/ships/klingon/kling_dockmove.wav" , 4 , 2 , 4384 );

	//--- move the base and arm out
	thread globalAccelMoveX( $bossDock_Arm, (-1 * BOSS_DOCK_ARM_DISTANCE), BOSS_DOCK_ARM_TIME, "rampupdown", "" );
	thread globalAccelMoveX( $bossDock_Base, (-1 * BOSS_DOCK_BASE_DISTANCE), BOSS_DOCK_BASE_TIME, "rampupdown", "" );
	wait( 2.75 );
	

        //**** ZAK ****
	$bossDock_RightScanner_Base1.playsound ( "sound/ships/klingon/kling_scanrot.wav" , 3 , .7 , 4384 );

	//--- rotate the scanners
	thread globalAccelMove_RotateY( $bossDock_RightScanner_Base1, 70, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RotateY( $bossDock_LeftScanner_Base1, -70, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RotateY( $bossDock_RightScanner_SubBase1, -70, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RotateY( $bossDock_LeftScanner_SubBase1, 70, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RelativeY( $bossDock_RightScanner_SubBase2, BOSS_DOCK_SCANNER_DISTANCE, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RelativeY( $bossDock_LeftScanner_SubBase2, BOSS_DOCK_SCANNER_DISTANCE, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RotateY( $bossDock_RightScanner, 40, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RotateY( $bossDock_LeftScanner, -40, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	wait( 1.75 );
	
	//--- lock the arm locks
	thread globalAccelMoveZ( $bossDock_ArmLock_Top, (-1 * BOSS_DOCK_ARMLOCK_DISTANCE), BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	globalAccelMoveZ( $bossDock_ArmLock_Bottom, BOSS_DOCK_ARMLOCK_DISTANCE, BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	
	//--- set the flag
	boolBossDock_BaseExtended = TRUE;
}


//---------------------
// arenaBossDock_ExtendPhase2
// position the scanners around the boss and emit the shields
//---------------------
void arenaBossDock_ExtendPhase2()
{
        //**** ZAK ****
	$bossDock_RightScanner_Base1.playsound ( "sound/ships/klingon/kling_scanrot.wav" , 2 , .7 , 4384 );

	//--- rotate the scanners
	thread globalAccelMove_RotateY( $bossDock_RightScanner_Base1, 21, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RotateY( $bossDock_LeftScanner_Base1, -21, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RelativeY( $bossDock_RightScanner_SubBase3, BOSS_DOCK_SCANNER_DISTANCE, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RelativeY( $bossDock_LeftScanner_SubBase3, BOSS_DOCK_SCANNER_DISTANCE, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RelativeY( $bossDock_RightScanner_Base2, BOSS_DOCK_SCANNER_DISTANCE, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RelativeY( $bossDock_LeftScanner_Base2, BOSS_DOCK_SCANNER_DISTANCE, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	
	thread globalAccelMove_RotateY( $bossDock_RightScanner, 41, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	globalAccelMove_RotateY( $bossDock_LeftScanner, -41, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	wait( .25 );
	
        //**** ZAK ****
	$boss_rig_forcefield.playsound ( "sound/ships/klingon/kling_ffstart.wav" , 5 , 1 , 4384 );
	$boss_rig_forcefield.loopsound ( "sound/ships/enterprise/ent_forcefield.wav" , .7 , 2384 );

	//--- activate the forcefield
	$boss_rig_forcefield.show();
	$boss_rig_forcefield.solid();
}


//---------------------
// arenaBossDock_RetractPhase1
// lower the forcefield and position the scanners
//---------------------
void arenaBossDock_RetractPhase1()
{
	//--- activate the forcefield

        //**** ZAK ****
	$boss_rig_forcefield.playsound ( "sound/ships/klingon/kling_ffstart.wav" , 5 , 1 , 4384 );
	$boss_rig_forcefield.stoploopsound ();

	$boss_rig_forcefield.hide();
	$boss_rig_forcefield.notSolid();
	wait( .25 );
	

        //**** ZAK ****
	$bossDock_RightScanner_Base1.playsound ( "sound/ships/klingon/kling_scanrot.wav" , 3 , .7 , 4384 );

	//--- rotate the scanners
	thread globalAccelMove_RotateY( $bossDock_RightScanner_Base1, -21, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RotateY( $bossDock_LeftScanner_Base1, 21, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RelativeY( $bossDock_RightScanner_SubBase3, (-1 * BOSS_DOCK_SCANNER_DISTANCE), BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RelativeY( $bossDock_LeftScanner_SubBase3, (-1 * BOSS_DOCK_SCANNER_DISTANCE), BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RelativeY( $bossDock_RightScanner_Base2, (-1 * BOSS_DOCK_SCANNER_DISTANCE), BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RelativeY( $bossDock_LeftScanner_Base2, (-1 * BOSS_DOCK_SCANNER_DISTANCE), BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	
	thread globalAccelMove_RotateY( $bossDock_RightScanner, -41, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	globalAccelMove_RotateY( $bossDock_LeftScanner, 41, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
}


//---------------------
// arenaBossDock_RetractPhase2
// retact the arm and base
//---------------------
void arenaBossDock_RetractPhase2()
{
	//--- set the flag
	boolBossDock_BaseExtended = FALSE;
	
	//--- release the arm locks
	thread globalAccelMoveZ( $bossDock_ArmLock_Top, BOSS_DOCK_ARMLOCK_DISTANCE, BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	globalAccelMoveZ( $bossDock_ArmLock_Bottom, (-1 * BOSS_DOCK_ARMLOCK_DISTANCE), BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	wait( .3 );


        //**** ZAK ****
	$bossDock_Arm.playsound ( "sound/ships/klingon/kling_dockmove.wav" , 4 , 1 , 4384 );

	//--- move the base and arm in
	thread globalAccelMoveX( $bossDock_Arm, BOSS_DOCK_ARM_DISTANCE, BOSS_DOCK_ARM_TIME, "rampupdown", "" );
	thread globalAccelMoveX( $bossDock_Base, BOSS_DOCK_BASE_DISTANCE, BOSS_DOCK_BASE_TIME, "rampupdown", "" );
	wait( 2.75 );
	
	//--- rotate the scanners
	thread globalAccelMove_RotateY( $bossDock_RightScanner_Base1, -70, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RotateY( $bossDock_LeftScanner_Base1, 70, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RotateY( $bossDock_RightScanner_SubBase1, 70, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RotateY( $bossDock_LeftScanner_SubBase1, -70, BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RelativeY( $bossDock_RightScanner_SubBase2, (-1 * BOSS_DOCK_SCANNER_DISTANCE), BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RelativeY( $bossDock_LeftScanner_SubBase2, (-1 * BOSS_DOCK_SCANNER_DISTANCE), BOSS_DOCK_SCANNER_TIME, "rampup", "" );
	thread globalAccelMove_RotateY( $bossDock_RightScanner, -40, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	thread globalAccelMove_RotateY( $bossDock_LeftScanner, 40, BOSS_DOCK_SCANNER_TIME, "rampupdown", "" );
	wait( 2 );
	
	//--- lock the arm locks
	thread globalAccelMoveZ( $bossDock_ArmLock_Top, (-1 * BOSS_DOCK_ARMLOCK_DISTANCE), BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );
	globalAccelMoveZ( $bossDock_ArmLock_Bottom, BOSS_DOCK_ARMLOCK_DISTANCE, BOSS_DOCK_ARMLOCK_TIME, "rampup", "" );	
}




//===================================================================================================================================================
//===================================================================================================================================================
// COMMON FUNCTIONS
//===================================================================================================================================================
//===================================================================================================================================================

//---------------------
// commonGet_AngularDistance
// vecTarget - vector, the target point
// vecStart - vector, the starting point
// returns - float, the angular distance from the start point, to the target point
// calculates the angular distance between two points
//---------------------
float commonGet_AngularDistance( vector vecTarget, vector vecStart )
{
	//--- variables
	float intTargetAngle;
	float intStartAngle;
	float intAngularDistance;
	
	//--- get the angles for the starting point and the target point
	intTargetAngle = globalMath_GetXYAngleForPointAboutCenter( vecTarget, $boss_rig_mover.getorigin() );
	intStartAngle = globalMath_GetXYAngleForPointAboutCenter( vecStart, $boss_rig_mover.getorigin() );

	//--- get the angular distance from the starting point, to the target point
	intAngularDistance = globalMath_GetCircularDistanceInDegrees( intTargetAngle, intStartAngle );
	
	return( intAngularDistance );
}




//---------------------
// commonGet_WithinAngularTolerance
// intAngularDistance - float, the angular distance between two points
// intAngularTolerance - float, the tolerance used to determine
//						 if the angular distance falls within (plus and minus)
// returns - float, TRUE if it does, FALSE if it does not
// determines if a passed in angular distance falls within the passed in angular tolerance
//---------------------
float commonGet_WithinAngularTolerance( float intAngularDistance, float intAngularTolerance )
{
	
	//--- is the angular distance within the passed in angluar tolerance zone
	if( intAngularDistance <= intAngularTolerance && intAngularDistance >= (-1 * intAngularTolerance) )
	{
		return( TRUE );
	}

	return( FALSE );
}

void coop_bindAndHide(entity e1,entity e2)
{
	if(doesEntityExist(e1) == 1 && doesEntityExist(e2) == 1){
		e1.bind(e2);
		e1.hide();
	}
}


void coop_rigBossAttackClosest()
{
	while(float_bossInVehicle){
		eBossHatesMe = globalCoop_return_playerClosestActive($boss_rig);
		$boss_rig.attack(eBossHatesMe);
		wait(5);
	}
}

float coop_checkPlayerIsDeath()
{
	if(!cvar_bool_multiplayer){
		if( $player.getHealth() <= 0 ){
			return 1;
		}
	}
	return 0;
}

void coop_hideRig()
{
//MOVE MOVE MOVE
	vector_rigRestoreLocation = $boss_rig_mover.getOrigin();
	$boss_rig_mover.time(.01);
	$boss_rig_mover.movetoPos('0 0 -2222');
}


void coop_showRig()
{
//MOVE MOVE MOVE
	$boss_rig_mover.time(.02);
	$boss_rig_mover.movetoPos(vector_rigRestoreLocation);
}


void coop_endLevel()
//------------------------------------------------------------------------------
//Level end
//------------------------------------------------------------------------------
{
//MISSION 9 ENDS HERE, SHOW SUCESS HUD THEN
	coop_bool_showMissionSucessHud=1;
	//thread globalCoop_mission_completed("ent-deck1_bridge");
	thread globalCoop_mission_completed("m10l1-romulan_installation");
}


