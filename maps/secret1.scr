//-----------------------------------------------------------------
//
//  EF2/LOTR Level Script File
//
//  Level:					ent-training5
//  Script By:				Kenny T
//  Geometry By:			Kenny T
//  Created on:				6/14/2002
//  Updated for Coop on:	2007.01.11 Chrissstrahl
//  Last Edited:			2007.04.08 Chrissstrahl
//
//-----------------------------------------------------------------

//-----------------------------------------------------------------
//-----------------------------------------------------------------
//  DEFINE SCRIPT
//-----------------------------------------------------------------
//-----------------------------------------------------------------

void main();
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
void coop_secret1_tMultiple0a();
void coop_secret1_tMultiple0b();
// WATER SCRIPT FUNCTIONS DECLARATION, DO NOT HAVE THE NAMES OF FUNCTIONS DUBLICATED/REDECLARED!
void	hzm_waterTouched();
void	hzm_waterTakeCareOfPlayer(entity ePlayer,entity eTrigger);
float	hzm_waterCheckBB(vector vOri1,vector vMins1,vector vMaxs1,vector vOri2,vector vMins2,vector vMaxs2,float fPad);
float	hzm_waterReturnFloatNotNegative(float fNotNegative);
float	hzm_waterCheckValueOfGiven(float fValue,float fGiven);
void	hzm_waterPlayerLeakAir(entity ePlayer,entity eTrigger);
void	hzm_waterShakeAndMoveUp(entity eBubble,entity eTrigger);
//GLOBAL VARIABLES
// THIS VARIABLES ARE ACCESSABLE FROM WITHIN EVERY FUNCTION, DO NOT HAVE THE NAMES DUBLICATED!
float	hzm_water_float_checkAssiningToucher;//Don't touch this one it's set automaticly
float	hzm_water_integer_airTime = 12;			//(12 MIN:5) Time how long in sec the player can stand under water before he leaks air
float	hzm_water_integer_damageInvervall = 3;	//(3 MIN:3) Player leak air all x sec when still under water
float	hzm_water_float_damageDivider = 1;		//(1) player takes damage the time he is under water, 5 secounds = 5 damage, 
												//the divider factor works like this: 25-secounds / 5-divider = 5 damage
float	hzm_water_integer_minimumBubbles = 3;	//(3 MAX:11) air bubles minimum leaked per damage
float	hzm_water_integer_maximumBubbles = 10;	//(6 MAX:12) air bubles maximum leaked per damage and leaked when player gets drown
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
void holoDeckSetup();
void holoDeckFadeOut();
void holoDeckFadeIn();
void init();
	
void lurkerFromDeck();
void lurkerBustUpFromDeck();

void lurkerDoorOpenGo();
void lurkerDoorBreaksCeling();

void lurkerFromBehindBox();

void sendLurkerThroughFrontDoor();
void knockDownFrontDoor();

void sendLurkerThroughUpStairsDoor();

void counterTopDoorGo();

void cycleUpStairsLighting();

void threadCallLightning1();
void threadCallLightning2();
void threadCallLightning3();
void threadCallLightning4();
void threadCallLightning5();
void threadCallLightning6();
void threadCallLightning7();

void callLightning( float whichBoltToUse, float flashInsideLighningLights );
void SetupLighting();
void lightningFlash( float randomLightningShouldBeChoosen, string lightningSetNamePreFix, float shouldLightsBeTurnedOn );
void moveLight1( entity lightToMove, float angularVelocityInDegreesPerSecond );
void coop_endLevel();
void immobilizeEmAll();

//-----------------------------------------------------------
//-----------------------------------------------------------
//--- variables

float lightningIsReadyToBeCallTriggered = 1;
float numberOfLurkersKilled = 0;
float totalNumberOfLurkers = 5;
float frontDorLurkerNotKilled = 1;//coop
float downStairsDoor1Action;//coop
float float_immobilize_emAll=1;//coop


//-----------------------------------------------------------------
//-----------------------------------------------------------------
//  INCLUDES
//-----------------------------------------------------------------
//-----------------------------------------------------------------

//Co-op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
#include "coop_mod/maps/main.scr"
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#include "maps/global_scripts/global_common.scr"
#include "maps/global_scripts/global_debugUtils.scr"
#include "maps/global_scripts/global_math.scr"

//-----------------------------------------------------------------
//-----------------------------------------------------------------
//  MAIN THREAD
//-----------------------------------------------------------------
//-----------------------------------------------------------------
void main()
{
	cam_fadeout( .001, 0, 0, 0, 1, 0 );
	cache( "char/alien-type1a-lurker.tik" );
	$sky.rendereffects( "+skyorigin" );
	//$world.weather("rain_plain",400);
	$world.weather("rain",400);
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	coop_vector_lmsStartedPausedWarmuptime_z = 10;//set lms warmuptime to 10 no matter what else is setup
	coop_string_nextMapToCheck			= "secret2";//set the map we gona load next while we are in testmode
//Set spawnangles for this level
	coop_float_spawnAngle0 			= 180;//SpawnOrigin0 Angle
	coop_float_spawnAngle1 			= 180;//SpawnOrigin1 Angle
	coop_float_spawnAngle2 			= 180;//SpawnOrigin2 Angle
	coop_float_spawnAngle3 			= 90;//SpawnOrigin3 Angle
	coop_float_spawnAngle4 			= 90;//SpawnOrigin4 Angle
	coop_float_spawnAngle5 			= -90;//SpawnOrigin5 Angle
	coop_float_spawnAngle6 			= -90;//SpawnOrigin6 Angle
	coop_float_spawnAngle7 			= 180;//SpawnOrigin7 Angle
	coop_float_spawnAngle8 			= 180;//SpawnOrigin8 Angle
//Definie Objective
	coop_string_objectiveItem1			= "secretObjectiveS1";
//Give each player a Item/weapon, the integer stands for the player-ID
	coop_string_weapon1 				= "models/weapons/worldmodel-FieldAssaultRifle.tik";
	coop_string_weapon2 				= "models/weapons/worldmodel-BurstRifle.tik";
	coop_string_weapon3 				= "models/weapons/worldmodel-CompressionRifle.tik";
	coop_string_weapon4 				= "models/weapons/worldmodel-Phaser-stx.tik";
	coop_string_weapon5 				= "models/weapons/worldmodel-Tricorder-stx.tik";

	
//spawnorigins, Spawn Players on those locations, at map start
	coop_vector_spawnOrigin1 			= '1559 188 -70';
	//coop_vector_respawnOrigin1 			= '1800 188 -70';//dev test temp
	coop_vector_spawnOrigin2 			= '1559 62 -60';
	coop_vector_spawnOrigin3			= '1234 -95 -70';
	coop_vector_spawnOrigin4 			= '1129 -95 -66';
	coop_vector_spawnOrigin5 			= '1129 366 -66';
	coop_vector_spawnOrigin6 			= '1230 366 -66';
	coop_vector_spawnOrigin7 			= '1454 197 -60';
	coop_vector_spawnOrigin8 			= '1454 40 -50';
//Start the Co-Op Script

	globalCoop_main();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	//--- set the world
	//$skyDome.hide();
	//--- set the sky portal
	thread holoDeckSetup();
	init();
	
/* 	wait(5);
	cprint("TEST!===========================\n");
	print("spawn===========================\n");
	spawn("camera","targetname","coop_cam1","origin","0 0 0");
	spawn("camera","targetname","coop_cam2","origin","0 0 0");
	spawn("script_origin","targetname","originator","origin","100 0 30");
	wait(.1);
	print("cuecamera===========================\n");	
	$coop_cam1.follow($originator);
	$coop_cam1.follow_distance(0);
	cuecamera($coop_cam1);
	//$coop_cam1.
	$originator.setvelocity('0 0 2');
	$originator.angles('45 0 0');
	while(1){
		cuecamera($coop_cam1);wait(.2);
	} */
	
//Wait for a player to enter the game
	waitForPlayer();
	$world.clearAvailableViewModes();
	$world.addAvailableViewMode( "none" );
		

//For Multiplayer ONLY, spawn some things
	if(cvar_bool_multiplayer)
	{
/* 	//The connections to the world outside
		spawn("trigger_multiple", "targetname", "tMultiple0a", "origin", "-461 -26 65", "thread", "coop_secret1_tMultiple0a");
		spawn("trigger_multiple", "targetname", "tMultiple0b", "origin","-531 -26 65", "thread", "coop_secret1_tMultiple0b");
		spawn("trigger_multiple", "targetname", "tMultiple1a", "origin", "573 -121 40", "thread", "coop_secret1_tMultiple1a");
		spawn("trigger_multiple", "targetname", "tMultiple1b", "origin", "573 -159 40", "thread", "coop_secret1_tMultiple1b");
		wait(.1);
		$tMultiple0a.setsize( '-0 -100 -30', '0 100 40' );//Ramp Size
		$tMultiple0b.setsize( '-0 -100 -30', '0 100 40' );//Ramp Size
		$tMultiple1a.setsize( '-50 -0 -30', '120 0 40' );//Ramp Size
		$tMultiple1b.setsize( '-50 -0 -30', '120 0 40' );//Ramp Size */
		spawn("trigger_multiple", "targetname", "tMultiple1Water", "origin", "1843 -1459 -244", "thread", "hzm_waterTouched");
		spawn("trigger_multiple", "targetname", "tMultiple2Water", "origin", "1843 -1459 -244", "thread", "hzm_waterTouched");
		spawn("trigger_multiple", "targetname", "tMultiple3Water", "origin", "1843 540 -244", "thread", "hzm_waterTouched");
		spawn("trigger_multiple", "targetname", "tMultiple4Water", "origin", "1843 2540 -244", "thread", "hzm_waterTouched");		
		wait(.1);
		$tMultiple1Water.setsize( '-800 -2200 -200', '650 0 117' );
		$tMultiple2Water.setsize( '-800 -0 -200', '650 2000 117' );
		$tMultiple3Water.setsize( '-800 -0 -200', '650 2000 117' );
		$tMultiple4Water.setsize( '-800 -0 -200', '650 1800 117' );
	//For more shake :)
		spawn( "func_earthquake", "targetname", "lightningQuake1");
	}
	
//Call the thunder ^^
	thread callLightning( 0, 0 );
}

//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
void coop_secret1_tMultiple0a()
//----------------------------------------------------------------------------
// This is a way to get out of/in to the Swampshack, some kind of
// special Transporter...
//----------------------------------------------------------------------------
{
entity e;
	$tMultiple0b.nottriggerable();//prevent a bug
	e = $tMultiple0a.getLastActivatingEntity();
	
	if( doesEntityExist(e) ){
		e.hudprint("^1You left the Swampshack\n");
		e.origin( '-560 -32 -10');
	}
	wait( 0.025);
	$tMultiple0b.triggerable();
}


void coop_secret1_tMultiple0b()
//----------------------------------------------------------------------------
// This is a way to get out of/in to the Swampshack, some kind of
// special Transporter...
//----------------------------------------------------------------------------
{
if(frontDorLurkerNotKilled){thread sendLurkerThroughFrontDoor();}//Co-Op
entity e;
	$tMultiple0a.nottriggerable();//prevent a bug
	e = $tMultiple0b.getLastActivatingEntity();
	if( doesEntityExist(e) ){
		e.hudprint("^1You entered the Swampshack\n");
		e.origin( '-420 -26 0');
	}
	wait( 0.025 );
	$tMultiple0a.triggerable();
}

void coop_secret1_tMultiple1a()
//----------------------------------------------------------------------------
// This is a way to get out of/in to the Swampshack, some kind of
// special Transporter...
//----------------------------------------------------------------------------
{
entity e;
	$tMultiple1b.nottriggerable();//prevent a bug
	e = $tMultiple1a.getLastActivatingEntity();
	
	if( doesEntityExist(e) ){
		e.hudprint("^1You left the Swampshack\n");
		e.origin( '573 -200 10');
	}
	wait( 0.025);
	$tMultiple1b.triggerable();
	
}
void coop_secret1_tMultiple1b()
//----------------------------------------------------------------------------
// This is a way to get out of/in to the Swampshack, some kind of
// special Transporter...
//----------------------------------------------------------------------------
{
entity e;
	$tMultiple1a.nottriggerable();//prevent a bug
	e = $tMultiple1b.getLastActivatingEntity();
	
	if( doesEntityExist(e) ){
		e.hudprint("^1You entered the Swampshack\n");
		e.origin( '573 -80 30');
	}
	wait( 0.025);
	$tMultiple1a.triggerable();
	
}


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

//------------------------
// this thread sets up the Holo Deck And Player
//------------------------
void holoDeckSetup()
{
	globalCommon_SpawnScriptModel( "enviro/enterprise_holo-deck.tik", "holoDeck", '1350 109 -80', 0 );
	wait(.01);
	if(doesEntityExist($holoDeck)){
		$holoDeck.notsolid();
		$holoDeck.rendereffects( "+depthhack" );
		$holoDeck.forcealpha( 1 );
		$holoDeck.alpha( 1 );
	}
	if(cvar_bool_multiplayer){
		$holoDeck.origin('900 100 -140');
		$holoDeck.scale(2.7);
	}
	else{
		waitForPlayer();
		$holoDeck.origin( $player.getorigin() );
	}
	thread holoDeckFadeOut();
}

//------------------------
// this thread makes the Holo Deck Fade Out
//------------------------
void holoDeckFadeOut()
{
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	globalCoop_main_waitForWarmupTime();
	
	if(cvar_bool_multiplayer)//Multi Player Mode )
	{
		waitForPlayer();
		thread immobilizeEmAll();
		wait(4);
		$holoDeck.fade( 3, 0 );
		wait( 1 );
//set fog, a foggy holodeck looks strange //wather - FOG effect
		$world.farplane ( 2000 );//2000
		$world.farplane_color( '0.1 0.12 0.1' );//'0.1 0.12 0.1'
		$world.entity_fade_dist( 4500 );//4500
		wait( 1 );
//allow players to move again
		float_immobilize_emAll=0;
		wait( 1 );
		$holoDeck.hide();
		//$holoDeck.alpha( 0 );
		$holoDeck.remove();//remove as fading in makes no sence if all players are spread all over the level
	}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////	
	else
	{
		waitForPlayer();
		$player.loadobjectives( "secret1" );
		cam_fadein( .5, 0, 0, 0, 1, 0 );
		$player.immobilize(1);
		$player.setobjectiveshow( "secretObjectiveS1", 1 );
		$holoDeck.fade( 3, 0 );
		wait( .5 );
//set fog, a foggy holodeck looks strange //wather - FOG effect
		$world.farplane ( 2000 );//2000
		$world.farplane_color( '0.1 0.12 0.1' );//'0.1 0.12 0.1'
		$world.entity_fade_dist( 4500 );//4500
		wait( 2.5 );
		$player.immobilize(0);
		$holoDeck.hide();
		$holoDeck.alpha( 0 );
		level_ai ( 1 );
	}
}

//------------------------
// this thread makes the Holo Deck Fade Out
//------------------------
void holoDeckFadeIn()
{
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	if(cvar_bool_multiplayer){//Multi Player Mode )
		globalCoop_objectives_update("complete",1,1);//State,Item,ShowIt
		wait(2);
		coop_endLevel();
		return;
	}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	else{
		$player.setobjectivecomplete( "secretObjectiveS1", 1 );
		wait( 3 );
		$player.immobilize( 1 );
		$holoDeck.origin( $player.getorigin() );
		$holoDeck.show();
		$holoDeck.fadein( 2, 1 );
		wait( 2 );
		$holoDeck.alpha( 1 );
		wait( 2 );
		spawn ( "trigger_changelevel", "targetname", "trigger_endlevel", "map", "secret3" );
		wait ( .5 );
		trigger ( "$trigger_endlevel" );
		wait(4);
		stuffcmd ( "disconnect\n" );
	}
}


void init()
{
	vector vvv;	
	//Setup Lightning
	SetupLighting();
	
	thread cycleUpStairsLighting();
	
	//Setup swinging lights
	$celingLight1.bind( $celingLightOrigin1 );
	$celingDLight1.bind( $celingLightOrigin1 );
	
	$celingLight2.bind( $celingLightOrigin2 );
	$celingDLight2.bind( $celingLightOrigin2 );
	
	$celingLight3.bind( $celingLightOrigin3 );
	$celingDLight3.bind( $celingLightOrigin3 );
	
	$celingDLight1.hide();
	$celingDLight2.hide();
	$celingDLight3.hide();
	//Made not solid in editor, else dlights are off
	//$celingDLight1.notsolid();
	
	$celingDLight1.lightRadius( 196 );
 	$celingDLight1.lightOn();
 	$celingDLight2.lightRadius( 196 );
 	$celingDLight2.lightOn();
 	$celingDLight3.lightRadius( 196 );
 	$celingDLight3.lightOn();
	
	// setup counter Top
	$counterDoor.bind( $counterDoorOrigin );
	thread globalCommon_OnUse ( $counterDoor , "counterTopDoorGo" );
	
	//setup Broken deck pieces
	$deckBusted.hide();
	$deckBusted.notsolid();
	$deckBustedPiece1.hide();
	$deckBustedPiece1.notsolid();
	$deckBustedPiece2.hide();
	$deckBustedPiece2.notsolid();
	$deckBustedPiece3.hide();
	$deckBustedPiece3.notsolid();
	$deckBustedPiece4.hide();
	$deckBustedPiece4.notsolid();
	$deckBustedPiece5.hide();
	$deckBustedPiece5.notsolid();
	
	$deckSolid.notsolid();
	
	$deckBustedPiece1.bind( $deckBustedPieceOrigin1 );
	$deckBustedPiece2.bind( $deckBustedPieceOrigin2 );
	$deckBustedPiece3.bind( $deckBustedPieceOrigin3 );
	$deckBustedPiece4.bind( $deckBustedPieceOrigin4 );
	$deckBustedPiece5.bind( $deckBustedPieceOrigin5 );
	
	// Setup First Door Lurker
	$lurkerBustUpDeck.thread( "lurkerBustUpFromDeck" );
	$triggerLurkerFromDeck.thread( "lurkerFromDeck" );
	vvv = $triggerLurkerFromDeck.getMins();
	vvv_x -= 380;
	$triggerLurkerFromDeck.setSize(vvv,$triggerLurkerFromDeck.getMaxs());
	vvv_x -= 400;
	$triggerLurkerFrontDoor.setSize(vvv,$triggerLurkerFrontDoor.getMaxs());
	
	$lurkerPusher3.nottriggerable();
	$cabinCeling1.notsolid();
	//$cabinCeling2.notsolid();
	
	$downStairsDoor1.bind( $downStairsDoorOrigin1 );
	thread globalCommon_OnUse ( $downStairsDoor1 , "lurkerDoorOpenGo" );
	$lurkerJumpsUpFloors.thread( "lurkerDoorBreaksCeling" );
	
	//Setup Lurker BehindBox
	$triggerLurkerFromBehindBox.thread( "lurkerFromBehindBox" );
	$lurkerPusher4.speed( 600 );
	
	//Set up Lurk Through Front Door
	$frontDoorPiece1.notsolid();
	$frontDoor1.notsolid();
	$frontDoor1.bind( $frontDoorOrigin1 );
	$frontDoorPiece1.bind( $frontDoorOrigin1 );
	$triggerLurkerFrontDoor.thread( "sendLurkerThroughFrontDoor" );
	$triggerKnockDownFrontDoor.thread( "knockDownFrontDoor" );
	
	//Set up Lurk Through Upstairs Door
	$upStairsDoor1.bind( $upStairsDoorOrigin1 );
	$upStairsDoorPiece1.bind( $upStairsDoorOrigin1 );
	thread globalCommon_OnUse ( $upStairsDoorPiece1, "sendLurkerThroughUpStairsDoor" );


	if(!cvar_bool_multiplayer)//Co-Op
	{
		$world.playsound( "sound/player/player_invpickup.wav", 3, 1, 10000 );
		$player.give( "models/weapons/worldmodel-Phaser-stx.tik" );
		$player.give( "models/weapons/worldmodel-CompressionRifle.tik" );
		$player.give( "models/weapons/worldmodel-FieldAssaultRifle.tik" );
		
		$player.ammo( "Plasma", 200 );
		$player.ammo( "Phaser", 200 );
		$player.ammo( "Disruptor", 200 );
		$player.ammo( "Idryll", 200 );
		$player.ammo( "Fed", 200 );

		$player.armor( "BasicArmor", 100 );
		
		$player.use("models/weapons/worldmodel-FieldAssaultRifle.tik");
	}
	else{
		globalCoop_main_waitForWarmupTime();
	}
	thread globalCoop_objectives_update("inComplete",1,1);//State,Item,ShowIt
}

//------------------------
// Lurker Pops up from deck
//------------------------
void lurkerFromDeck()
{
	$triggerLurkerFromDeck.nottriggerable();
	$lurkerPusher1.angles( '-72 0 0' );
	$lurkerPusher1.speed( 200 );
	
	$lurkerPusher2.angles( '-10 0 0' );
	$lurkerPusher2.speed( 400 );

	$deckSolid.hide();
	$deckBusted.show();
	$deckBustedPiece1.show();
	$deckBustedPiece2.show();
	$deckBustedPiece3.show();
	$deckBustedPiece4.show();
	$deckBustedPiece5.show();
	globalCommon_SpawnActor( "char/alien-type1a-lurker.tik", "lurker1", '602.00 130.00 -30.00', 0 );
	$lurker1.anim( "idle" );
	$lurker1.scale( 1.2 );
	$lurker1.lightRadius( 128 );
	$lurker1.lightOn();
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	$lurker1.health(globalCoop_return_floatMultiplicatedPlayerQuantity($lurker1.gethealth()));//Co-Op Health Multiplier
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	$lurker1.killthread( "checkNumberOfLurkersDead" );
	entity e;
	e = spawn("script_model","model","fx/fx-dummy.tik","origin",vectorTostring($deckClip.getOrigin()));
	globalCoop_main_waitAFrame();
	e.setSize($deckClip.getMins(),$deckClip.getMaxs());
	e.bind($deckClip);
	$deckClip.moveUp( 48 );
	$deckClip.time( .1 );
	waitfor( $deckClip );
	wait( 2 ); 
	$lurkerPusher1.remove();//Co-op
	$lurkerPusher2.remove();//Co-op

}

//------------------------
//Called when lurker hits trigger in busting up from deck
//------------------------
void lurkerBustUpFromDeck()
{
	$lurkerBustUpDeck.nottriggerable();
	
	$deckBustedPieceOrigin1.time( .15 );
	$deckBustedPieceOrigin2.time( .2 );
	$deckBustedPieceOrigin3.time( .15 );
	$deckBustedPieceOrigin4.time( .15 );
	$deckBustedPieceOrigin5.time( .2 );
	
	$deckBustedPieceOrigin1.rotateXdown( 100 );
	$deckBustedPieceOrigin1.rotateYup( 45 );
	
	$deckBustedPieceOrigin2.rotateXup( 175 );
	$deckBustedPieceOrigin2.rotateYdown( 25 );
	
	$deckBustedPieceOrigin3.rotateXdown( 105 );
	
	$deckBustedPieceOrigin4.rotateXup( 170 );
	$deckBustedPieceOrigin4.rotateYup( 25 );
	
	$deckBustedPieceOrigin5.rotateXdown( 120 );
	$deckBustedPieceOrigin5.rotateYdown( 35 );
	
	if( !doesEntityExist( $lurker1 ) )//Co-op
		return;

	$lurker1.anim( "attack_charge_pounce" );
	waitforanimation( $lurker1, "attack_charge_pounce" );

	if( !doesEntityExist( $lurker1 ) )//Co-op
		return;

	$lurker1.anim( "attackcombo1" );
	$lurker1.lightOff();
	waitforanimation( $lurker1, "attackcombo1" );

	if( !doesEntityExist( $lurker1 ) )//Co-op
		return;

	$lurker1.anim( "idle" );
	$lurker1.ai_on();
}



//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
void downStairsDoor1()
//------------------------
//downSTairsDoor1 can now open and close again
//------------------------
{
	if(downStairsDoor1Action){downStairsDoor1Action = 0;}
	else{downStairsDoor1Action = 1;}
	if($downStairsDoorOrigin1.getFloatvar("state") == 0){
		downStairsDoor1Action = 0;
		$downStairsDoorOrigin1.setfloatvar( "state", 2);
		$downStairsDoorOrigin1.time( 0.8 );
		$downStairsDoorOrigin1.rotateYup( 90 );
		$downStairsDoorOrigin1.angle( 180 );
		waitFor( $downStairsDoorOrigin1 );
		wait( .1 );
		$downStairsDoorOrigin1.setfloatvar( "state", 1);
	}
	else if($downStairsDoorOrigin1.getFloatvar("state") == 1){
		downStairsDoor1Action = 0;
		$downStairsDoorOrigin1.setfloatvar( "state", 2);
		$downStairsDoorOrigin1.time( 0.8 );
		$downStairsDoorOrigin1.rotateYdown( 90 );
		$downStairsDoorOrigin1.angle( 90 );
		waitFor( $downStairsDoorOrigin1 );
		wait( .1 );
		$downStairsDoorOrigin1.setfloatvar( "state", 0);
	}
	else if($downStairsDoorOrigin1.getFloatvar("state") == 2){
		waitFor($downStairsDoorOrigin1);
		wait(.1);
		if(downStairsDoor1Action){
			thread downStairsDoor1();
		}
	}
}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

//------------------------
//Called when First Door Used, Lurker jumps upstairs
//------------------------
void lurkerDoorOpenGo()
{
	$downStairsDoor1.noUse();
	$lurkerPusher3.speed( 1000 );
	
	//Call Lightning Strike
	thread callLightning( 2, 2 );
	$downStairsDoorOrigin1.time( 1 );
	$downStairsDoorOrigin1.rotateYdown( 90 );
	globalCommon_SpawnActor( "char/alien-type1a-lurker.tik", "lurker2", '100.68 878.68 16.00', 70 );
	if(doesEntityExist($lurker2)){
		$lurker2.anim( "idle" );
		$lurker2.scale( 1.2 );
		$lurker2.lightRadius( 128 );
		$lurker2.lightOn();
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
		$lurker2.health(globalCoop_return_floatMultiplicatedPlayerQuantity($lurker2.gethealth()));//Co-Op Health	Multiplier
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
		$lurker2.killthread( "checkNumberOfLurkersDead" );
	}
	wait(0.5);
	if(doesEntityExist($lurker2)){
		$lurker2.anim( "takeoff" );
	}
 	wait( 0.5 );
	$lurkerPusher3.triggerable();

 	wait( 3 );//Co-op
	$lurkerPusher3.remove();//Co-op

 	if( doesEntityExist($cabinCeling1)){//Co-op
		$cabinCeling1.solid();
	}
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	spawn("trigger_use", "targetname", "tDownStairsDoor1","thread", "downStairsDoor1", "origin", "200 852 100" );
	wait(.25);
	$tDownStairsDoor1.setsize( '-20 -20 -10', '20 20 10' );//triggerBox
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
}

//------------------------
//Lurker Door Breaks through celing
//------------------------
void lurkerDoorBreaksCeling()
{
	$lurkerJumpsUpFloors.nottriggerable();
	
	$cabinCeling1.remove();
	wait( .25 );
	$lurker2.origin( '84 652 216' );
	$lurker2.angle( 270 );
	$lurker2.ai_on();
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	if(doesEntityExist($lurker2))
		if(cvar_bool_multiplayer){//Multi Player Mode )
			wait( 2 );
			$lurker2.sleep();//just fuck off!!!
		}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
}

//------------------------
//Lurker Jumps From Back Of Box
//------------------------
void lurkerFromBehindBox()
{
	$triggerLurkerFromBehindBox.nottriggerable();
	
	//Call Lightning Strike
	thread callLightning( 0, 3 );
	
	globalCommon_SpawnActor( "char/alien-type1a-lurker.tik", "lurker3", '65.60 317.60 56.00', 90 );
	$lurker3.scale( 1.2 );
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	$lurker3.health(globalCoop_return_floatMultiplicatedPlayerQuantity($lurker3.gethealth()));//Co-Op Health Multiplier
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	$lurker3.killthread( "checkNumberOfLurkersDead" );
	if( doesEntityExist( $lurker3 ) ){//Co-Op
		$lurker3.anim( "attackcombo3" );
		waitforanimation( $lurker3, "attackcombo3" );
	}
		
		
	if( doesEntityExist( $lurker3 ) ){//Co-Op
		$lurker3.ai_on();
	}
}

//------------------------
//Lurker Busts Through front door
//------------------------
void sendLurkerThroughFrontDoor()
{
	frontDorLurkerNotKilled = 0;//Co-Op
	$triggerLurkerFrontDoor.nottriggerable();

	$lurkerPusher5.angles( '350 0 0' );
	$lurkerPusher5.speed( 400 );
	
	globalCommon_SpawnActor( "char/alien-type1a-lurker.tik", "lurker4", '-200 -34  8', 0 );
	$lurker4.scale( 1.2 );
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	$lurker4.health(globalCoop_return_floatMultiplicatedPlayerQuantity($lurker4.gethealth()));//Co-Op Health Multiplier
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	$lurker4.killthread( "checkNumberOfLurkersDead" );
	$lurker4.anim( "crash" );
	waitforanimation( $lurker4, "crash" );
	if(doesEntityExist($lurker4)){
		$lurker4.anim( "attackcombo2" );
		wait( .05 );
		if(doesEntityExist($lurker4)){$lurker4.ai_on();}
	}
	else{
		knockDownFrontDoor();
	}	
	$lurkerPusher5.remove();//Co-Op
}

//------------------------
//Lurker Busts Through front door
//------------------------
void knockDownFrontDoor()
{
	$triggerKnockDownFrontDoor.nottriggerable();
	
	$frontDoorOrigin1.time( .3 );
	$frontDoorOrigin1.rotateYup( 90 );
	wait( .1 );
	if(doesEntityExist($frontDoorPiece1)){
		$frontDoorPiece1.remove();
	}
	
	//Call Lightning Strike
	thread callLightning( 3, 2 );
}

//------------------------
//Lurker Busts Through Upstairs door
//------------------------
void sendLurkerThroughUpStairsDoor()
{
	$upStairsDoorPiece1.nouse();
	
	globalCommon_SpawnActor( "char/alien-type1a-lurker.tik", "lurker5", '314.00 290.00 204.00', 180 );
	$upStairsDoorPiece1.notsolid();
	$upStairsDoor1.notsolid();
	$lurker5.scale( 1.2 );
//Co-Op
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	$lurker5.health(globalCoop_return_floatMultiplicatedPlayerQuantity($lurker5.gethealth()));//Co-Op Health Multiplier
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
	$lurker5.killthread( "checkNumberOfLurkersDead" );
	if(doesEntityExist($upStairsDoorExplode1)){trigger( "$upStairsDoorExplode1" );}
	
	$upStairsDoorOrigin1.time( .3 );
	$upStairsDoorOrigin1.rotateYdown( 90 );
	wait( .1 );
	$upStairsDoorPiece1.remove();
	
	if(getcVarint( "g_gametype" ) == 0){//Co-Op
		$lurker5.anim( "attack_charge_pounce" );
		waitforanimation( $lurker5, "attack_charge_pounce" );
	}
	
	//Call Lightning Strike
	thread callLightning( 0, 3 );
	
	$lurker5.anim( "attackcombo2" );
	wait( .05 );
	$lurker5.ai_on();
}

//---------------------------
// Check for Number Of Lurkers Dead
//---------------------------
void checkNumberOfLurkersDead()
{
	numberOfLurkersKilled += 1;
	if( numberOfLurkersKilled == totalNumberOfLurkers ){
		holoDeckFadeIn();
	}
}

//------------------------
//Counter Rotates Up
//------------------------
void counterTopDoorGo()
{
	$counterDoor.nouse();
	//Call Lightning Strike
	thread callLightning( 0, 3 );
	
	$counterDoorOrigin.time( 1 );
	$counterDoorOrigin.rotateZup( 110 );
	waitfor( $counterDoorOrigin );
}

//------------------------
//Sets cycling Up Stairs Lighting
//------------------------
void cycleUpStairsLighting()
{
	float longWait, mediumWait, shortWait; 
		
	while( 1 )
	{
		longWait = randomint( 2 ) + .3;
		mediumWait = randomint( 1 ) + 1;
		shortWait = randomint( .4 ) + .1;
		
		$world.light_lightstyle( "lampLightInside" , "a" , 0 );
		$celingLightcone4.hide();
		wait( longWait ); //off
		$world.light_lightstyle( "lampLightInside" , "z" , 0 );
		$celingLightcone4.show();
		wait( shortWait );//on
		$world.light_lightstyle( "lampLightInside" , "a" , 0 );
		$celingLightcone4.hide();
		wait( shortWait );//off
		$world.light_lightstyle( "lampLightInside" , "z" , 0 );
		$celingLightcone4.show();
		wait( shortWait );//on
		$world.light_lightstyle( "lampLightInside" , "a" , 0 );
		$celingLightcone4.hide();
		wait( mediumWait );//off
		$world.light_lightstyle( "lampLightInside" , "z" , 0 );
		$celingLightcone4.show();
		wait( longWait );//on
		$world.light_lightstyle( "lampLightInside" , "a" , 0 );
		$celingLightcone4.hide();
		wait( mediumWait );//off
		$world.light_lightstyle( "lampLightInside" , "z" , 0 );
		$celingLightcone4.show();
		wait( shortWait );//on
		$world.light_lightstyle( "lampLightInside" , "a" , 0 );
		$celingLightcone4.hide();
		wait( shortWait );//off
		$world.light_lightstyle( "lampLightInside" , "z" , 0 );
		$celingLightcone4.show();
		wait( mediumWait );//on
	}
}

//------------------------
//Triggered Lightning Flashes
//------------------------
void threadCallLightning1()
{
	$triggerCallLightning1.nottriggerable();
	
	callLightning( 4, 0 );
	wait( .1 );
	
	$triggerCallLightning1.triggerable();
}

void threadCallLightning2()
{
	$triggerCallLightning2.nottriggerable();

	callLightning( 4, 0 );
	wait( .1 );
	
	$triggerCallLightning2.triggerable();
}

void threadCallLightning3()
{
	$triggerCallLightning3.nottriggerable();
	
	callLightning( 1, 0 );
	wait( .1 );
	
	$triggerCallLightning3.triggerable();
}

void threadCallLightning4()
{
	$triggerCallLightning4.nottriggerable();
	
	callLightning( 2, 2 );
	wait( .1 );
	
	$triggerCallLightning4.triggerable();
}

void threadCallLightning5()
{
	$triggerCallLightning5.nottriggerable();
	
	callLightning( 2, 3 );
	wait( .1 );
	
	$triggerCallLightning5.triggerable();
}

void threadCallLightning6()
{
	$triggerCallLightning6.nottriggerable();
	
	callLightning( 2, 2 );
	wait( .1 );
	
	$triggerCallLightning6.triggerable();
}

void threadCallLightning7()
{
	$triggerCallLightning7.nottriggerable();
	
	callLightning( 3, 0 );
	wait( .1 );
	
	$triggerCallLightning7.triggerable();
}

//------------------------
//Makes Lightning Flash
//------------------------
void callLightning( float whichBoltToUse, float flashInsideLighningLights )
{
	if( lightningIsReadyToBeCallTriggered == 1 )
	{
		$world.playsound("sound/environment/nature/thunder3.wav", 0, 3, 7000 );
		lightningIsReadyToBeCallTriggered = 0;
		
		if( whichBoltToUse == 0 )
		{
			//Flash Lightning( Choose Random Set of Lightning Bolts 0 = no 1 = yes, Name of Pre-determined Set of Lightning Bolts, Should D-Lights Be Flickerd 1=random 2=front 3=back 0=none );
			thread lightningFlash( 1, " ", flashInsideLighningLights );

			thread moveLight1( $celingLightOrigin1, 2 );
			thread moveLight1( $celingLightOrigin2, 2 );
			moveLight1( $celingLightOrigin3, 2 );
			
			lightningIsReadyToBeCallTriggered = 1;
		}
		if( whichBoltToUse == 1 )
		{
			//Flash Lightning( Choose Random Set of Lightning Bolts 0 = no 1 = yes, Name of Pre-determined Set of Lightning Bolts, Should D-Lights Be Flickerd 1 = random 2 = front 3 = back 0 = none );
			thread lightningFlash( 0, "lightninga", flashInsideLighningLights );

			thread moveLight1( $celingLightOrigin1, 2 );
			thread moveLight1( $celingLightOrigin2, 2 );
			moveLight1( $celingLightOrigin3, 2 );
			
			lightningIsReadyToBeCallTriggered = 1;
		}
		if( whichBoltToUse == 2 )
		{
			//Flash Lightning( Choose Random Set of Lightning Bolts 0 = no 1 = yes, Name of Pre-determined Set of Lightning Bolts, Should D-Lights Be Flickerd 1 = random 2 = front 3 = back 0 = none );
			thread lightningFlash( 0, "lightningb", flashInsideLighningLights );

			thread moveLight1( $celingLightOrigin1, 2 );
			thread moveLight1( $celingLightOrigin2, 2 );
			moveLight1( $celingLightOrigin3, 2 );
			
			lightningIsReadyToBeCallTriggered = 1;
		}
		if( whichBoltToUse == 3 )
		{
			//Flash Lightning( Choose Random Set of Lightning Bolts 0 = no 1 = yes, Name of Pre-determined Set of Lightning Bolts, Should D-Lights Be Flickerd 1 = random 2 = front 3 = back 0 = none );
			thread lightningFlash( 0, "lightningc", flashInsideLighningLights );

			thread moveLight1( $celingLightOrigin1, 2 );
			thread moveLight1( $celingLightOrigin2, 2 );
			moveLight1( $celingLightOrigin3, 2 );
			
			lightningIsReadyToBeCallTriggered = 1;
		}
		if( whichBoltToUse == 4 )
		{
			//Flash Lightning( Choose Random Set of Lightning Bolts 0 = no 1 = yes, Name of Pre-determined Set of Lightning Bolts, Should D-Lights Be Flickerd 1 = random 2 = front 3 = back 0 = none );
			thread lightningFlash( 0, "lightningd", flashInsideLighningLights );

			thread moveLight1( $celingLightOrigin1, 2 );
			thread moveLight1( $celingLightOrigin2, 2 );
			moveLight1( $celingLightOrigin3, 2 );
			
			lightningIsReadyToBeCallTriggered = 1;
		}
	}
}

//------------------------
//Hides Lighting
//------------------------
void SetupLighting()
{
	// This thread hides the scriptobjects in the skybox related to the lightning
	
	float LightningVisualIndex;
	float MAX_lightningFlashObjects;
	float i;
	string lightningFlashName;
	entity lightningFlashObject;

	LightningVisualIndex = 1;
	MAX_lightningFlashObjects = 4;
	for ( i = MAX_lightningFlashObjects; i >= 1; i-- )
	{
		lightningFlashName = "lightninga" + LightningVisualIndex;
		lightningFlashObject = getentity( lightningFlashName );
		lightningFlashObject.hide();
		LightningVisualIndex += 1;
	}

	LightningVisualIndex = 1;
	MAX_lightningFlashObjects = 4;
	for ( i = MAX_lightningFlashObjects; i >= 1; i-- )
	{
		lightningFlashName = "lightningb" + LightningVisualIndex;
		lightningFlashObject = getentity( lightningFlashName );
		lightningFlashObject.hide();
		LightningVisualIndex += 1;
	}
	
	LightningVisualIndex = 1;
	MAX_lightningFlashObjects = 4;
	for ( i = MAX_lightningFlashObjects; i >= 1; i-- )
	{
		lightningFlashName = "lightningc" + LightningVisualIndex;
		lightningFlashObject = getentity( lightningFlashName );
		lightningFlashObject.hide();
		LightningVisualIndex += 1;
	}
	
	LightningVisualIndex = 1;
	MAX_lightningFlashObjects = 4;
	for ( i = MAX_lightningFlashObjects; i >= 1; i-- )
	{
		lightningFlashName = "lightningd" + LightningVisualIndex;
		lightningFlashObject = getentity( lightningFlashName );
		lightningFlashObject.hide();
		LightningVisualIndex += 1;
	}
	
	//TurnOff Dynamic Lights in area
	$world.light_lightstyle( "lightningLightFront" , "a" , 0 );
	$world.light_lightstyle( "lightningLightBack" , "a" , 0 );
	
	$triggerCallLightning1.thread( "threadCallLightning1" );
	$triggerCallLightning2.thread( "threadCallLightning2" );
	$triggerCallLightning3.thread( "threadCallLightning3" );
	$triggerCallLightning4.thread( "threadCallLightning4" );
	$triggerCallLightning5.thread( "threadCallLightning5" );
	$triggerCallLightning6.thread( "threadCallLightning6" );
	$triggerCallLightning7.thread( "threadCallLightning7" );
}

//------------------------
// Starts the lightning flashing.
//------------------------
void lightningFlash( float randomLightningShouldBeChoosen, string lightningSetNamePreFix, float shouldLightsBeTurnedOn )		
{
	float LightningTime;
	float LightningBrightness;
	float LightningCountFlashes;
	float LightningVisualIndex;
	float MAX_lightningFlashObjects;
	float i;
	float LightningLastFlash;
	float randomLightningSet;
	
	string lightningFlashName;
	string lightningLightToTurnOn;
	
	entity lightningFlashObject;

	LightningVisualIndex = 1;
	MAX_lightningFlashObjects = 4;

	// Randomly select lighning group set if desired else use a preditermined set 
	if( randomLightningShouldBeChoosen == 1 )
	{
		randomLightningSet = randomint( 4 ) + 1;
		if( randomLightningSet == 1 ){ lightningSetNamePreFix = "lightninga"; }
		if( randomLightningSet == 2 ){ lightningSetNamePreFix = "lightningb"; }
		if( randomLightningSet == 3 ){ lightningSetNamePreFix = "lightningc"; }
		if( randomLightningSet == 4 ){ lightningSetNamePreFix = "lightningd"; }
	}

	//decide which side of Swampshack lightning is comming from
	if( shouldLightsBeTurnedOn ==  1 )
	{
		if( randomint( 2 ) == 1 ){ lightningLightToTurnOn = "lightningLightFront"; }
		else{ lightningLightToTurnOn = "lightningLightBack"; }
	}
	else if( shouldLightsBeTurnedOn ==  2 )
	{
		lightningLightToTurnOn = "lightningLightFront";
	}			
	else if( shouldLightsBeTurnedOn ==  3 )
	{
		lightningLightToTurnOn = "lightningLightBack";
	}
	else{ lightningLightToTurnOn = " "; }

	LightningCountFlashes = randomint ( 5 ) + 3;

	while ( LightningCountFlashes >= 1 )
	{
		LightningTime = randomfloat( 0.15 ) + .05;
		LightningBrightness = randomfloat ( 0.5 ) + .2;

		//centerprint( "Count =" + LightningCountFlashes + " Time =" + LightningTime + " Brightness =" + LightningBrightness + "\n" );

		//Rock the camera!
		if(doesEntityExist($lightningQuake1)){
			$lightningQuake1.duration( 1 );
			$lightningQuake1.magnitude(( LightningBrightness / 2 ) + .2 );
		}

		if(doesEntityExist($lightningQuake1)){trigger( "$lightningQuake1" );}

		lightningFlashName = lightningSetNamePreFix + LightningVisualIndex;

		//print ( lightningFlashName + "\n" );

		lightningFlashObject = getentity( lightningFlashName );

		if( doesEntityExist( lightningFlashObject ) )
		{
			lightningFlashObject.show();
			lightningFlashObject.fadein( .05 );
			lightningFlashObject.alpha ( 1 );
		}
		//No good lightning sounds.
		// if ( LightningCountFlashes <= 1 )
		// {
			//if ( LightningBrightness >= .5 )
				//$world.playsound( "sound/environment/weather/thunder1.wav", 3, 2, 256 );
			//else
				// $world.playsound( "sound/environment/weather/thunder1.wav", 3, 2, 256 );
		// }

		// Lights on!
		cam_fadeout( LightningTime, 1, 1, 1, (LightningBrightness / 2), 0 );
		if( doesEntityExist( lightningFlashObject ) )
		{		
			lightningFlashObject.fade( LightningTime );
		}
		$world.light_lightstyle( lightningLightToTurnOn , "z" , 0 );

		wait ( LightningTime / 4 );
		$world.light_lightstyle( lightningLightToTurnOn , "u" , 0 );
		wait ( LightningTime / 4 );
		$world.light_lightstyle( lightningLightToTurnOn , "n" , 0 );
		wait ( LightningTime / 4 );
		$world.light_lightstyle( lightningLightToTurnOn , "g" , 0 );
		wait ( LightningTime / 4 );

		// Lights Off
		cam_fadein( LightningTime, 1, 1, 1, (LightningBrightness / 2), 0 );
		$world.light_lightstyle( lightningLightToTurnOn , "a" , 0 );

		LightningCountFlashes -= 1;

		LightningLastFlash = LightningVisualIndex;

		LightningVisualIndex = randomint ( MAX_lightningFlashObjects );
		LightningVisualIndex ++;

		if ( LightningLastFlash == LightningVisualIndex )
		{
			LightningVisualIndex ++;
		}
	}
}

//------------------------
// this thread swings d-light s
//------------------------
void moveLight1( entity lightToMove, float angularVelocityInDegreesPerSecond )
{
	float angularVelocityDampiner = .96;
		
	float angleInDegrees = 0;
	
	float acceleration;
	acceleration = randomint( 2 );
	if( acceleration == 0 ){ acceleration = -1; }	
	
	float directionOfAcceleration = 1;
	
	float generateRandomAngle;
	generateRandomAngle= randomint( 4 ) - 1.9;
	
	float randomDirectionX = 1;
	float randomDirectionY = 1;
	float randomDirectionZ = 1;
	
	//randomDirectionX = randomint( 2 );
	//if( randomDirectionX == 0 ){ randomDirectionX = -1; }
	randomDirectionY = randomint( 2 );
	if( randomDirectionY == 0 ){ randomDirectionY = -1; }	
	randomDirectionZ = randomint( 2 );
	if( randomDirectionZ == 0 ){ randomDirectionZ = -1; }	
	
	vector originalLightVector;
	vector lightVector;
	
	lightVector = $celingLightOrigin1.getangles();
	originalLightVector = lightVector;
	
	while( angularVelocityInDegreesPerSecond > .1 || acceleration > 0.1  )
	{
		while( angularVelocityInDegreesPerSecond > .01 )
		{
			acceleration = angleInDegrees * -1.5;
			angleInDegrees += ( angularVelocityInDegreesPerSecond * .05 );
			angularVelocityInDegreesPerSecond += ( directionOfAcceleration * acceleration * .05 );

			lightVector_x += ( angularVelocityInDegreesPerSecond * randomDirectionX );
			lightVector_y = lightVector_y + (( angularVelocityInDegreesPerSecond / generateRandomAngle ) * randomDirectionY );
			lightVector_z += ( angularVelocityInDegreesPerSecond * randomDirectionX );

			lightToMove.angles( lightVector );
			wait( .05 );

			angularVelocityInDegreesPerSecond *= angularVelocityDampiner; 
		}
		while( angularVelocityInDegreesPerSecond < .01 )
		{
			acceleration = angleInDegrees * -1.5;

			angleInDegrees += ( angularVelocityInDegreesPerSecond * ( 1 / 20 ) );
			angularVelocityInDegreesPerSecond += ( directionOfAcceleration * acceleration * ( 1 / 20 ) );

			lightVector_x += angularVelocityInDegreesPerSecond;
			lightVector_y = lightVector_y + ( angularVelocityInDegreesPerSecond / generateRandomAngle );
			lightVector_z += angularVelocityInDegreesPerSecond;


			lightToMove.angles( lightVector );
			wait( .05 );

			angularVelocityInDegreesPerSecond *= angularVelocityDampiner; 
		}
	}
	lightToMove.angles( originalLightVector );
}


void immobilizeEmAll()
{
	entity ePlayer;
	float fPlayerId;
	while(float_immobilize_emAll)
	{
		for(fPlayerId=1;fPlayerId<coop_integer_maxPlayers;fPlayerId++)
		{
			ePlayer = getEntity("player"+fPlayerId);
			if(doesEntityExist(ePlayer))
			{
				ePlayer.immobilize(1);
			}
		}
		globalCoop_main_waitAFrame();
	}
	
	for(fPlayerId=1;fPlayerId<coop_integer_maxPlayers;fPlayerId++)
	{
		ePlayer = getEntity("player"+fPlayerId);
		if(doesEntityExist(ePlayer))
		{
			ePlayer.immobilize(0);
		}
	}
}


void hzm_waterTouched()
////////////////////////////////////////////////////////////////////////////////
//let us know that someone is taking a bath (some dude touched a trigger)
////////////////////////////////////////////////////////////////////////////////
{
//IF THIS THREAD IS RUNNING DO NOT CALL IT, WAIT FOR THE TRIGGER TO FIRE AGAIN.
//THIS AVOIDS THAT THIS FUNCTION IS CALLED MULTIPLE TIMES ON THE SAME PLAYER
	if(!hzm_water_float_checkAssiningToucher){
//LOCK DOWN THIS FUCNTION
		hzm_water_float_checkAssiningToucher=1;
//CREATE VARIABLES FROM TYPE ENTITY/OBJECT
		entity eTrigger;
//GRAB THE CURRENT OBJECT, WICH IS THE TRIGGER CALLING THIS THREAD
		eTrigger = getCurrentEntity();
//CHECK IF THE TRIGGER EXISTS
		if(doesEntityExist(eTrigger)){
//CREATE VARIABLES FROM TYPE ENTITY/OBJECT
			entity ePlayer;
//GRAB ENTITY WHICH HAS ACTIVATED THE TRIGGER (WHICH IS A PLAYER!)
			ePlayer = eTrigger.getlastActivatingEntity();
//CHECK IF THE PLAYER EVEN EXISTS
			if(doesEntityExist(ePlayer)){
//START THE FUNCTION WHICH TAKES CARE OF THE PLAYER AND CHECK IF THE PLAYER IS IN/UNDER THE WATER
//START IT AS "THREAD" SO THIS THREAD CAN END AND DOES NOT WAIT FOR THE PLAYER TO LEAVE TEH WATER AGAIN.
				thread hzm_waterTakeCareOfPlayer(ePlayer,eTrigger);
			}
		}
//HAVE A DELAY HERE, TO AVOID THAT THIS THREAD CALLS TWICE ON THE SAME PLAYER
		wait(.1);
//UNLOCK THIS FUNCTION
		hzm_water_float_checkAssiningToucher=0;
	}
}


void hzm_waterTakeCareOfPlayer(entity ePlayer,entity eTrigger)
////////////////////////////////////////////////////////////////////////////////
//Take Care of the player under water :D, check if player is still in/under water
////////////////////////////////////////////////////////////////////////////////
{
//blub blub->z==44 crouched
//blub blub->z==86 stand
	if(doesEntityExist(ePlayer) && doesEntityExist(eTrigger)){
		if(ePlayer.getFloatvar("hzm_waterTakeCareOfPlayer") != 1){
			ePlayer.setFloatVar("hzm_waterTakeCareOfPlayer",1);
			float fHealth,fIsUnderWaterTime,fDamage,fBuble,fRandom;
			vector vTrig,vBBoxMin,vBBoxMax,vPlayer,vPlayerMax,vTimeArray;
//GET ONLY ONCE, THIS TRIGGER IS NOT SUPPOSE TO MOVE
			vTrig = eTrigger.getOrigin();
			vBBoxMin = eTrigger.getMins();
			vBBoxMax = eTrigger.getMaxs();	
//CHECK BEFORE USE
 			if(hzm_water_integer_minimumBubbles > 9){
				hzm_water_integer_minimumBubbles = 9;
			}
			if(hzm_water_integer_maximumBubbles > 10){
				hzm_water_integer_maximumBubbles = 10;
			} 
			if(hzm_water_integer_damageInvervall < 3){
				hzm_water_integer_damageInvervall = 3;
			}
			if(hzm_water_integer_airTime < 5){
				hzm_water_integer_airTime = 5;
			}
			vTimeArray = ePlayer.getVectorVar("lastUnderWaterTime");
			if((vTimeArray_x + .3) > getLevelTime()){
				fIsUnderWaterTime = vTimeArray_y;
			}
			
//GET/CHEK THIS ALL THE TIME
			while(doesEntityExist(ePlayer)){
				fHealth = ePlayer.getHealth();				
				if(fHealth > 0){
					vPlayer = ePlayer.getOrigin();
					vPlayerMax = ePlayer.getMaxs();
					
 					if(vPlayerMax_z == 49){
						vPlayerMax = '22 22 44';
					}
					else{
						vPlayerMax = '22 22 86';
					}
					
					if((vPlayer_z + vPlayerMax_z) <= (vTrig_z + vBBoxMax_z) && (vTrig_z + vBBoxMin_z) <= (vPlayer_z + vPlayerMax_z)){//(vPlayer_z + vMaxs_z) <= fCalcTriggerZTop
						vTimeArray_x = getLevelTime();
						vTimeArray_y = fIsUnderWaterTime;
						
						if(hzm_waterCheckBB(vTrig,vBBoxMin,vBBoxMax,vPlayer,'-22 -22 0',vPlayerMax,0)){
							
							fIsUnderWaterTime++;
							fDamage = ((fIsUnderWaterTime / 10) / hzm_water_float_damageDivider);
							if((fIsUnderWaterTime / 10) >= hzm_water_integer_airTime){
								if(hzm_waterCheckValueOfGiven((fIsUnderWaterTime / 10),hzm_water_integer_damageInvervall)){
									fHealth = (fHealth - fDamage);
									if(fHealth < 1){
 										for(fBuble=hzm_water_integer_maximumBubbles;fBuble>0;fBuble--){
											thread hzm_waterPlayerLeakAir(ePlayer,eTrigger);
										}
										ePlayer.killed(ePlayer,fDamage,ePlayer,1);
										ePlayer.setVectorVar("lastUnderWaterTime",vTimeArray);
										ePlayer.setFloatVar("hzm_waterTakeCareOfPlayer",0);
										return;
									}
									else{
										ePlayer.hurt(1);
										ePlayer.health(fHealth); 
										ePlayer.playSound("sound/player/player_gulp.wav",3,7,12);
 										fRandom = (randomInt((hzm_water_integer_maximumBubbles - hzm_water_integer_minimumBubbles)) + hzm_water_integer_minimumBubbles);
										for(fBuble=fRandom;fBuble>0;fBuble--){
											thread hzm_waterPlayerLeakAir(ePlayer,eTrigger);
										}
									}
								}
							}
						}
						else{
							ePlayer.setVectorVar("lastUnderWaterTime",vTimeArray);
							ePlayer.setFloatVar("hzm_waterTakeCareOfPlayer",0);
							return;
						}
					}
 					else{
						ePlayer.setVectorVar("lastUnderWaterTime",vTimeArray);
						ePlayer.setFloatVar("hzm_waterTakeCareOfPlayer",0);
						return;
					}
				}
				else{
					ePlayer.setVectorVar("lastUnderWaterTime",vTimeArray);
					ePlayer.setFloatVar("hzm_waterTakeCareOfPlayer",0);
					return;
				} 
				wait(.1);
			}
		}
	}
}


void hzm_waterPlayerLeakAir(entity ePlayer,entity eTrigger)
////////////////////////////////////////////////////////////////////////////////
//Spawn some buble sprites at the player his head location, plus some lil offset
////////////////////////////////////////////////////////////////////////////////
{
	if(doesEntityExist(ePlayer) && doesEntityExist(eTrigger)){
		ePlayer.morph("MORPH_O",120,0.3,1);
		vector vOrigin,vOriginTrigger,vTriggerMaxOrigin;
		entity eBubble,eSplash;
		vOrigin = ePlayer.getOrigin();
//DUCKED, NOT DUCKED
		if(vectorGetZ(ePlayer.getMaxs()) == 49){
			vOrigin_z += 67;
		}
		else{
			vOrigin_z += 96;
		}
	
		vTriggerMaxOrigin	= eTrigger.getOrigin();
		vTriggerMaxOrigin_z	+= vectorGetZ(eTrigger.getMaxs());
		if((vOrigin_z + 8) < vTriggerMaxOrigin_z){
			eBubble = spawn("script_model","model","waterdrop1.spr","origin",vectortoString(vOrigin),"scale","0.001","notsolid","1");
			wait(.05);
			hzm_waterShakeAndMoveUp(eBubble,eTrigger);
			vOrigin = eBubble.getOrigin();
		}
		vOrigin_z = vTriggerMaxOrigin_z;
		eSplash = spawn("script_model","model","rainsplash.spr","origin",vectortoString(vOrigin),"scale","0.001","notsolid","1");
		wait(.05);
		if(doesEntityExist(eBubble)){
			eBubble.remove();
		}
		eSplash.time(.1);
		eSplash.rotateXdownto(90);		
		eSplash.playSound("sound/environment/water/drip.wav",3,2,15);
//SCALE SPLASH UP
		float fScale = .02,fMaxScale;
		fMaxScale = ((randomInt(10) / 100) + .1);
		while(fScale < fMaxScale){
			wait(.02);//.01
			fScale = (fScale + .02);//.01
			if(doesEntityExist(eSplash)){
				eSplash.scale(fScale);
			}
		}
//REMOVE SPLASH
		if(doesEntityExist(eSplash)){
			eSplash.remove();
		}
	}
}


void hzm_waterShakeAndMoveUp(entity eBubble,entity eTrigger)
////////////////////////////////////////////////////////////////////////////////
//move the given airbubble towards the surface and shake it, the deeper in water the faster they move up
////////////////////////////////////////////////////////////////////////////////
{
	if(doesEntityExist(eBubble) && doesEntityExist(eTrigger)){
		float fDirection,fRounds,fMoveAt,fCount,fRanomMaxZSpeed;
		vector vVelocity,vOriginTrigger,vBBoxMax,vBBoxMin,vBubleOrigin;
		vOriginTrigger = eTrigger.getOrigin();
		vBBoxMax = eTrigger.getMaxs();
		vBBoxMin = eTrigger.getMins();
		eBubble.scale(.15);
		
		while(hzm_waterCheckBB(vOriginTrigger,vBBoxMin,vBBoxMax,(vBubleOrigin = eBubble.getOrigin()),'0 0 0','0 0 8',(vVelocity_z / 10))){
			fRounds++;
			fCount++;
			fMoveAt = (randomInt(10) + 15);
			vVelocity_z = (randomint(((vOriginTrigger_z + vBBoxMax_z) - vBubleOrigin_z)) + 20 );
			if(fRounds >= fMoveAt || fCount == 1){
				fRounds = 0;
				fDirection = randomInt(4);
				if(fDirection==0){
					vVelocity_x = randomint(15);
					vVelocity_y = randomint(15);
				}
				else if(fDirection==1){
					vVelocity_x = randomint(-15);
					vVelocity_y = randomint(-15);
				}
				else if(fDirection==2){
					vVelocity_x = randomint(-15);
					vVelocity_y = randomint(-15);
				}
				else{
					vVelocity_x = randomint(15);
					vVelocity_y = randomint(15);
				}	
			}
//check da bubble
			if(doesEntityExist(eBubble)){
				if((vectorGetZ(eBubble.getOrigin()) + (vVelocity_z / 10)) >= (vOriginTrigger_z + vBBoxMax_z) ){
					return;
				}
			}
//da bubble quit, exit the loop
			else{
				return;
			}
			eBubble.setVelocity(vVelocity);
			wait(.01);
		}
	}
}


float hzm_waterCheckBB(vector vOri1,vector vMins1,vector vMaxs1,vector vOri2,vector vMins2,vector vMaxs2,float fPad)
//------------------------------------------------------------------------------
//HAZARD MODDING CO-OP MOD FUNCTION, DO GIVE CREDIT WHEN USE
//------------------------------------------------------------------------------
{
	float fTemp,fCalc;
 	vector vTemp1,vTemp2;
	if(vOri1 != vOri2){
		vTemp2 = (vTemp1 = '0 0 0');
		vTemp1_x = vOri1_x;
		vTemp2_x = vOri2_x;
		fTemp = ( floor(vectorLength(vTemp1 - vTemp2)) - fPad );
		
		if(vTemp1_x >= vTemp2_x){
			fCalc = vMaxs2_x / 2;
			if(	fTemp > (hzm_waterReturnFloatNotNegative(vMins1_x) + fCalc)){
				return 0;
			}
		}
		else{
			fCalc = hzm_waterReturnFloatNotNegative(vMins2_x);
			fCalc = (fCalc / 2);
			if(fTemp > (vMaxs1_x + fCalc)){
				return 0;
			}
		}
		vTemp2 = (vTemp1 = '0 0 0');
		vTemp1_y = vOri1_y;
		vTemp2_y = vOri2_y;
		fTemp = ( floor(vectorLength(vTemp1 - vTemp2)) - fPad );
		
		if(vTemp1_y >= vTemp2_y){
			fCalc = (vMaxs2_y / 2);
			if(	fTemp > (hzm_waterReturnFloatNotNegative(vMins1_y) + fCalc)){
				return 0;
			}
		}
		else{
			fCalc = hzm_waterReturnFloatNotNegative(vMins2_y);
			fCalc = (fCalc / 2);
			if(fTemp > (vMaxs1_y + fCalc)){
				return 0;
			}
		}
		vTemp2 = (vTemp1 = '0 0 0');
		vTemp1_z = vOri1_z;
		vTemp2_z = vOri2_z;
		fTemp = ( floor(vectorLength(vTemp1 - vTemp2)) - fPad );
		
		if(vTemp1_z <= vTemp2_z){
			fCalc = hzm_waterReturnFloatNotNegative(vMins2_z);
			if(	fTemp > (vMaxs1_z + fCalc)){
				return 0;
			}
		}
		else{
			fCalc = (vMaxs2_z / 2);
			if(fTemp > (hzm_waterReturnFloatNotNegative(vMins1_z) + fCalc)){
				return 0;
			}
		}
	}
	return 1;
}


float hzm_waterReturnFloatNotNegative(float fNotNegative)
////////////////////////////////////////////////////////////////////////////////
//do not return negative value
////////////////////////////////////////////////////////////////////////////////
{
	if(fNotNegative < 0){
		fNotNegative = (fNotNegative - (fNotNegative*2));
	}
	return fNotNegative;
}


float hzm_waterCheckValueOfGiven(float fValue,float fGiven)
////////////////////////////////////////////////////////////////////////////////
//check if the value is a power of the given integer
////////////////////////////////////////////////////////////////////////////////
{
	float fValueCalc;
	fValueCalc = (fValue / fGiven);
	fValueCalc = floor(fValueCalc);
	if((fValueCalc * fGiven) == fValue){
		return 1;
	}
	return 0;
}


void coop_endLevel()
//------------------------------------------------------------------------------
//Level end
//------------------------------------------------------------------------------
{
	thread globalCoop_mission_completed("secret2");
}

